{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 171, "column": 0}, "map": {"version":3,"sources":["file:///home/alpha/code/%40redbtn/webapp/src/lib/red.ts"],"sourcesContent":["/**\n * Red AI instance initialization for Next.js API routes\n */\nimport { Red, RedConfig } from '@redbtn/ai';\n\nconst config: RedConfig = {\n  redisUrl: process.env.REDIS_URL || \"redis://localhost:6379\",\n  vectorDbUrl: process.env.VECTOR_DB_URL || \"http://localhost:8200\",\n  databaseUrl: process.env.DATABASE_URL || \"http://localhost:5432\",\n  defaultLlmUrl: process.env.LLM_URL || \"http://localhost:11434\",\n};\n\nlet redInstance: Red | null = null;\n\n/**\n * Get or initialize the Red AI instance\n * Singleton pattern to avoid multiple initializations\n */\nexport async function getRed(): Promise<Red> {\n  if (!redInstance) {\n    redInstance = new Red(config);\n    await redInstance.load('webapp-api');\n    console.log('âœ… Red AI initialized successfully');\n  }\n  return redInstance;\n}\n\n/**\n * Synchronous access to Red instance (must be initialized first)\n * Use getRed() for guaranteed initialization\n */\nexport function getRedSync(): Red {\n  if (!redInstance) {\n    throw new Error('Red instance not initialized. Call getRed() first.');\n  }\n  return redInstance;\n}\n\n// Initialize immediately for synchronous access in API routes\n// This allows `import { red }` to work\nlet initPromise: Promise<Red> | null = null;\n\nif (!initPromise) {\n  initPromise = getRed();\n}\n\n// Export as named export for convenience\nexport const red = await initPromise;\n\n/**\n * Bearer token for API authentication\n */\nexport const BEARER_TOKEN = process.env.BEARER_TOKEN || `red_ai_sk_${Date.now()}`;\n"],"names":[],"mappings":"AAAA;;CAEC;;;;;;;;;;AACD;;AAEA,MAAM,SAAoB;IACxB,UAAU,QAAQ,GAAG,CAAC,SAAS,IAAI;IACnC,aAAa,QAAQ,GAAG,CAAC,aAAa,IAAI;IAC1C,aAAa,QAAQ,GAAG,CAAC,YAAY,IAAI;IACzC,eAAe,QAAQ,GAAG,CAAC,OAAO,IAAI;AACxC;AAEA,IAAI,cAA0B;AAMvB,eAAe;IACpB,IAAI,CAAC,aAAa;QAChB,cAAc,IAAI,wJAAG,CAAC;QACtB,MAAM,YAAY,IAAI,CAAC;QACvB,QAAQ,GAAG,CAAC;IACd;IACA,OAAO;AACT;AAMO,SAAS;IACd,IAAI,CAAC,aAAa;QAChB,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT;AAEA,8DAA8D;AAC9D,uCAAuC;AACvC,IAAI,cAAmC;AAEvC,IAAI,CAAC,aAAa;IAChB,cAAc;AAChB;AAGO,MAAM,MAAM,MAAM;AAKlB,MAAM,eAAe,QAAQ,GAAG,CAAC,YAAY,IAAI,CAAC,UAAU,EAAE,KAAK,GAAG,IAAI","debugId":null}},
    {"offset": {"line": 219, "column": 0}, "map": {"version":3,"sources":["file:///home/alpha/code/%40redbtn/webapp/src/lib/api-helpers.ts"],"sourcesContent":["/**\n * Helper functions for API routes\n */\nimport crypto from 'crypto';\n\nexport interface ChatMessage {\n  role: 'system' | 'user' | 'assistant';\n  content: string;\n}\n\nexport interface ChatCompletionRequest {\n  model: string;\n  messages: ChatMessage[];\n  stream?: boolean;\n  temperature?: number;\n  max_tokens?: number;\n  top_p?: number;\n  frequency_penalty?: number;\n  presence_penalty?: number;\n  stop?: string | string[];\n  chat_id?: string;\n  conversation_id?: string;\n  conversationId?: string;\n  session_id?: string;\n  sessionId?: string;\n  messageId?: string; // Client-provided message ID for reconnection support\n  [key: string]: unknown;\n}\n\n/**\n * Generate a unique ID for chat completion\n */\nexport function generateCompletionId(): string {\n  return `chatcmpl-${Date.now()}-${Math.random().toString(36).substring(7)}`;\n}\n\n/**\n * Extract the last user message from the conversation\n */\nexport function extractUserMessage(messages: ChatMessage[]): string {\n  const lastUserMessage = [...messages].reverse().find(m => m.role === 'user');\n  return lastUserMessage?.content || '';\n}\n\n/**\n * Extract conversation ID from request body\n */\nexport function getConversationIdFromBody(body: ChatCompletionRequest): string | undefined {\n  const possibleFields = [\n    'chat_id',\n    'chatId',\n    'conversation_id',\n    'conversationId',\n    'session_id',\n    'sessionId',\n    'thread_id',\n    'threadId'\n  ];\n\n  for (const field of possibleFields) {\n    if (body[field]) {\n      return body[field] as string;\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Generate a stable conversation ID from message history\n */\nexport function generateStableConversationId(messages: ChatMessage[]): string {\n  const firstUserMessage = messages.find(m => m.role === 'user');\n\n  if (!firstUserMessage) {\n    return `conv_${crypto.randomBytes(8).toString('hex')}`;\n  }\n\n  const hash = crypto.createHash('sha256')\n    .update(firstUserMessage.content)\n    .digest('hex')\n    .substring(0, 16);\n\n  return `conv_${hash}`;\n}\n\n/**\n * Get models list response\n */\nexport function getModelsList() {\n  return {\n    object: 'list',\n    data: [\n      {\n        id: 'Red',\n        object: 'model',\n        created: Math.floor(Date.now() / 1000),\n        owned_by: 'redbtn',\n        permission: [],\n        root: 'Red',\n        parent: null\n      }\n    ]\n  };\n}\n\n/**\n * Get specific model details\n */\nexport function getModelDetails(modelId: string) {\n  if (modelId === 'Red' || modelId === 'red') {\n    return {\n      id: 'Red',\n      object: 'model',\n      created: Math.floor(Date.now() / 1000),\n      owned_by: 'redbtn',\n      permission: [],\n      root: 'Red',\n      parent: null\n    };\n  }\n  return null;\n}\n"],"names":[],"mappings":"AAAA;;CAEC;;;;;;;;;;;;;;AACD;;AA6BO,SAAS;IACd,OAAO,CAAC,SAAS,EAAE,KAAK,GAAG,GAAG,CAAC,EAAE,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,SAAS,CAAC,IAAI;AAC5E;AAKO,SAAS,mBAAmB,QAAuB;IACxD,MAAM,kBAAkB;WAAI;KAAS,CAAC,OAAO,GAAG,IAAI,CAAC,CAAA,IAAK,EAAE,IAAI,KAAK;IACrE,OAAO,iBAAiB,WAAW;AACrC;AAKO,SAAS,0BAA0B,IAA2B;IACnE,MAAM,iBAAiB;QACrB;QACA;QACA;QACA;QACA;QACA;QACA;QACA;KACD;IAED,KAAK,MAAM,SAAS,eAAgB;QAClC,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,OAAO,IAAI,CAAC,MAAM;QACpB;IACF;IAEA,OAAO;AACT;AAKO,SAAS,6BAA6B,QAAuB;IAClE,MAAM,mBAAmB,SAAS,IAAI,CAAC,CAAA,IAAK,EAAE,IAAI,KAAK;IAEvD,IAAI,CAAC,kBAAkB;QACrB,OAAO,CAAC,KAAK,EAAE,gHAAM,CAAC,WAAW,CAAC,GAAG,QAAQ,CAAC,QAAQ;IACxD;IAEA,MAAM,OAAO,gHAAM,CAAC,UAAU,CAAC,UAC5B,MAAM,CAAC,iBAAiB,OAAO,EAC/B,MAAM,CAAC,OACP,SAAS,CAAC,GAAG;IAEhB,OAAO,CAAC,KAAK,EAAE,MAAM;AACvB;AAKO,SAAS;IACd,OAAO;QACL,QAAQ;QACR,MAAM;YACJ;gBACE,IAAI;gBACJ,QAAQ;gBACR,SAAS,KAAK,KAAK,CAAC,KAAK,GAAG,KAAK;gBACjC,UAAU;gBACV,YAAY,EAAE;gBACd,MAAM;gBACN,QAAQ;YACV;SACD;IACH;AACF;AAKO,SAAS,gBAAgB,OAAe;IAC7C,IAAI,YAAY,SAAS,YAAY,OAAO;QAC1C,OAAO;YACL,IAAI;YACJ,QAAQ;YACR,SAAS,KAAK,KAAK,CAAC,KAAK,GAAG,KAAK;YACjC,UAAU;YACV,YAAY,EAAE;YACd,MAAM;YACN,QAAQ;QACV;IACF;IACA,OAAO;AACT","debugId":null}},
    {"offset": {"line": 308, "column": 0}, "map": {"version":3,"sources":["file:///home/alpha/code/%40redbtn/webapp/src/app/api/v1/chat/completions/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { getRed } from '@/lib/red';\nimport {\n  ChatCompletionRequest,\n  generateCompletionId,\n  extractUserMessage,\n  getConversationIdFromBody,\n  generateStableConversationId\n} from '@/lib/api-helpers';\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body: ChatCompletionRequest = await request.json();\n\n    if (!body.messages || body.messages.length === 0) {\n      return NextResponse.json(\n        {\n          error: {\n            message: 'messages is required and must not be empty',\n            type: 'invalid_request_error',\n            code: 'invalid_messages'\n          }\n        },\n        { status: 400 }\n      );\n    }\n\n    const completionId = generateCompletionId();\n    const created = Math.floor(Date.now() / 1000);\n    const modelName = body.model || 'Red';\n    const userMessage = extractUserMessage(body.messages);\n\n    const conversationId =\n      getConversationIdFromBody(body) ||\n      request.headers.get('x-conversation-id') ||\n      generateStableConversationId(body.messages);\n\n    console.log(`ðŸ”— Using conversation ID: ${conversationId}`);\n\n    const red = await getRed();\n\n    const messageId = body.messageId || `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    if (body.stream) {\n      await red.messageQueue.startGeneration(conversationId, messageId);\n\n      const encoder = new TextEncoder();\n      \n      let subscriptionReady = false;\n      const subscriptionReadyPromise = new Promise<void>(resolve => {\n        const checkReady = () => {\n          if (subscriptionReady) {\n            resolve();\n          } else {\n            setTimeout(checkReady, 10);\n          }\n        };\n        checkReady();\n      });\n      \n      const generationPromise = (async () => {\n        try {\n          console.log('[Completions] Waiting for subscription to be ready...');\n          await subscriptionReadyPromise;\n          console.log('[Completions] Subscription ready, starting generation for', messageId);\n          \n          const responseStream = await red.respond(\n            { message: userMessage },\n            {\n              source: { application: 'redChat' },\n              stream: true,\n              conversationId,\n              messageId\n            }\n          );\n\n          for await (const chunk of responseStream) {\n            if (typeof chunk === 'object' && chunk._metadata) continue;\n            \n            if (typeof chunk === 'object' && chunk._status) {\n              await red.messageQueue.publishStatus(messageId, {\n                action: chunk.action,\n                description: chunk.description\n              });\n              continue;\n            }\n            \n            if (typeof chunk === 'object' && chunk._thinkingChunk) {\n              await red.messageQueue.publishThinkingChunk(messageId, chunk.content);\n              continue;\n            }\n            \n            if (typeof chunk === 'object' && chunk._toolStatus) {\n              await red.messageQueue.publishToolStatus(messageId, {\n                status: chunk.status,\n                action: chunk.action\n              });\n              continue;\n            }\n\n            if (typeof chunk === 'string') {\n              await red.messageQueue.appendContent(messageId, chunk);\n            } else {\n              const metadata = {\n                model: chunk.response_metadata?.model,\n                tokens: chunk.usage_metadata ? {\n                  input: chunk.usage_metadata.input_tokens,\n                  output: chunk.usage_metadata.output_tokens,\n                  total: chunk.usage_metadata.total_tokens\n                } : undefined\n              };\n              await red.messageQueue.completeGeneration(messageId, metadata);\n            }\n          }\n        } catch (error) {\n          console.error(`[Completions] Generation failed:`, error);\n          await red.messageQueue.failGeneration(\n            messageId,\n            error instanceof Error ? error.message : String(error)\n          );\n        }\n      })();\n      \n      const stream = new ReadableStream({\n        async start(controller) {\n          let streamClosed = false;\n          \n          const safeEnqueue = (data: Uint8Array) => {\n            if (streamClosed) {\n              console.log('[Completions] Skipping enqueue - stream already closed');\n              return false;\n            }\n            try {\n              controller.enqueue(data);\n              return true;\n            } catch (error) {\n              if (error instanceof Error && error.message.includes('Controller is already closed')) {\n                console.log('[Completions] Stream closed by client');\n                streamClosed = true;\n                return false;\n              }\n              throw error;\n            }\n          };\n          \n          try {\n            const initEvent = { type: 'init', messageId, conversationId };\n            console.log('[Completions] Sending init event and subscribing to Redis');\n            if (!safeEnqueue(encoder.encode(`data: ${JSON.stringify(initEvent)}\\n\\n`))) {\n              return;\n            }\n\n            console.log('[Completions] Subscribing to message queue...');\n            const messageStream = red.messageQueue.subscribeToMessage(messageId);\n            console.log('[Completions] Subscription established, signaling generation to start');\n\n            subscriptionReady = true;\n\n            for await (const event of messageStream) {\n              if (streamClosed) {\n                console.log('[Completions] Stream closed, stopping subscription');\n                break;\n              }\n              \n              console.log('[Completions] Received event from Redis:', event.type);\n              \n              if (event.type === 'init' && event.existingContent) {\n                const chunks = event.existingContent.match(/.{1,50}/g) || [];\n                for (const chunk of chunks) {\n                  if (!safeEnqueue(encoder.encode(`data: ${JSON.stringify({\n                    type: 'content',\n                    content: chunk\n                  })}\\n\\n`))) break;\n                }\n              } else if (event.type === 'chunk') {\n                if (!safeEnqueue(encoder.encode(`data: ${JSON.stringify({\n                  type: 'content',\n                  content: event.content\n                })}\\n\\n`))) break;\n              } else if (event.type === 'status') {\n                console.log('[Completions] Forwarding status:', event.action);\n                if (!safeEnqueue(encoder.encode(`data: ${JSON.stringify({\n                  type: 'status',\n                  action: event.action,\n                  description: event.description\n                })}\\n\\n`))) break;\n              } else if (event.type === 'thinking_chunk') {\n                if (!safeEnqueue(encoder.encode(`data: ${JSON.stringify({\n                  type: 'thinking_chunk',\n                  content: event.content\n                })}\\n\\n`))) break;\n              } else if (event.type === 'thinking') {\n                if (!safeEnqueue(encoder.encode(`data: ${JSON.stringify({\n                  type: 'thinking',\n                  content: event.content\n                })}\\n\\n`))) break;\n              } else if (event.type === 'tool_status') {\n                console.log('[Completions] Forwarding tool_status:', event.action);\n                if (!safeEnqueue(encoder.encode(`data: ${JSON.stringify({\n                  type: 'tool_status',\n                  status: event.status,\n                  action: event.action\n                })}\\n\\n`))) break;\n              } else if (event.type === 'complete') {\n                safeEnqueue(encoder.encode(`data: ${JSON.stringify({\n                  type: 'complete',\n                  metadata: event.metadata\n                })}\\n\\n`));\n                break;\n              } else if (event.type === 'error') {\n                safeEnqueue(encoder.encode(`data: ${JSON.stringify({\n                  type: 'error',\n                  error: event.error\n                })}\\n\\n`));\n                break;\n              }\n            }\n            \n            safeEnqueue(encoder.encode('data: [DONE]\\n\\n'));\n            if (!streamClosed) controller.close();\n          } catch (error) {\n            console.error(`[Completions] Stream error:`, error);\n            if (!streamClosed) {\n              safeEnqueue(encoder.encode(`data: ${JSON.stringify({\n                type: 'error',\n                error: error instanceof Error ? error.message : String(error)\n              })}\\n\\n`));\n              controller.close();\n            }\n          }\n        }\n      });\n\n      return new Response(stream, {\n        headers: {\n          'Content-Type': 'text/event-stream',\n          'Cache-Control': 'no-cache, no-transform',\n          'Connection': 'keep-alive',\n          'X-Accel-Buffering': 'no'\n        }\n      });\n    }\n\n    const response = await red.respond(\n      { message: userMessage },\n      {\n        source: { application: 'redChat' },\n        conversationId\n      }\n    );\n\n    const completion = {\n      id: completionId,\n      object: 'chat.completion',\n      created,\n      model: modelName,\n      conversationId: response.conversationId || conversationId,\n      choices: [\n        {\n          index: 0,\n          message: {\n            role: 'assistant',\n            content: typeof response.content === 'string' ? response.content : JSON.stringify(response.content)\n          },\n          finish_reason: 'stop'\n        }\n      ],\n      usage: {\n        prompt_tokens: 0,\n        completion_tokens: 0,\n        total_tokens: 0\n      }\n    };\n\n    return NextResponse.json(completion);\n  } catch (error: any) {\n    console.error('Completion error:', error);\n    return NextResponse.json(\n      {\n        error: {\n          message: error.message || 'Internal server error',\n          type: 'internal_error'\n        }\n      },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}