module.exports = [
"[project]/.next-internal/server/app/api/v1/messages/[messageId]/reconnect/route/actions.js [app-rsc] (server actions loader, ecmascript)", ((__turbopack_context__, module, exports) => {

}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/fs [external] (fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}),
"[externals]/path [external] (path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}),
"[externals]/os [external] (os, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[externals]/events [external] (events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}),
"[externals]/assert [external] (assert, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/tty [external] (tty, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tty", () => require("tty"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/dns [external] (dns, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("dns", () => require("dns"));

module.exports = mod;
}),
"[externals]/net [external] (net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}),
"[externals]/tls [external] (tls, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}),
"[externals]/buffer [external] (buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}),
"[externals]/string_decoder [external] (string_decoder, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("string_decoder", () => require("string_decoder"));

module.exports = mod;
}),
"[externals]/mongodb [external] (mongodb, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("mongodb", () => require("mongodb"));

module.exports = mod;
}),
"[externals]/node:crypto [external] (node:crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:crypto", () => require("node:crypto"));

module.exports = mod;
}),
"[externals]/node:async_hooks [external] (node:async_hooks, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:async_hooks", () => require("node:async_hooks"));

module.exports = mod;
}),
"[externals]/child_process [external] (child_process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("child_process", () => require("child_process"));

module.exports = mod;
}),
"[project]/src/lib/red.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

return __turbopack_context__.a(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {

/**
 * Red AI instance initialization for Next.js API routes
 */ __turbopack_context__.s([
    "BEARER_TOKEN",
    ()=>BEARER_TOKEN,
    "getRed",
    ()=>getRed,
    "getRedSync",
    ()=>getRedSync,
    "red",
    ()=>red
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$redbtn$2f$ai$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@redbtn/ai/dist/index.js [app-route] (ecmascript)");
;
const config = {
    redisUrl: process.env.REDIS_URL || "redis://localhost:6379",
    vectorDbUrl: process.env.VECTOR_DB_URL || "http://localhost:8200",
    databaseUrl: process.env.DATABASE_URL || "http://localhost:5432",
    defaultLlmUrl: process.env.LLM_URL || "http://localhost:11434"
};
let redInstance = null;
async function getRed() {
    if (!redInstance) {
        redInstance = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$redbtn$2f$ai$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Red"](config);
        await redInstance.load('webapp-api');
        console.log('âœ… Red AI initialized successfully');
    }
    return redInstance;
}
function getRedSync() {
    if (!redInstance) {
        throw new Error('Red instance not initialized. Call getRed() first.');
    }
    return redInstance;
}
// Initialize immediately for synchronous access in API routes
// This allows `import { red }` to work
let initPromise = null;
if (!initPromise) {
    initPromise = getRed();
}
const red = await initPromise;
const BEARER_TOKEN = process.env.BEARER_TOKEN || `red_ai_sk_${Date.now()}`;
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, true);}),
"[project]/src/app/api/v1/messages/[messageId]/reconnect/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

return __turbopack_context__.a(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {

__turbopack_context__.s([
    "GET",
    ()=>GET
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$red$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/red.ts [app-route] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$red$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__
]);
[__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$red$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__;
;
async function GET(request, { params }) {
    // Await params in Next.js 15
    const { messageId } = await params;
    console.log('[Reconnect] Reconnecting to stream for messageId:', messageId);
    try {
        const red = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$red$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getRed"])();
        const encoder = new TextEncoder();
        // Check if message exists in Redis
        const existingState = await red.messageQueue.getMessageState(messageId);
        if (!existingState) {
            console.log('[Reconnect] No state found for messageId:', messageId);
            return new Response(JSON.stringify({
                error: 'Message not found'
            }), {
                status: 404,
                headers: {
                    'Content-Type': 'application/json'
                }
            });
        }
        console.log('[Reconnect] Found existing state:', existingState.status, existingState.content?.length || 0, 'chars');
        // Create SSE stream
        const stream = new ReadableStream({
            async start (controller) {
                let streamClosed = false;
                // Helper to safely enqueue
                const safeEnqueue = (data)=>{
                    if (streamClosed) return false;
                    try {
                        controller.enqueue(data);
                        return true;
                    } catch (error) {
                        if (error instanceof Error && error.message.includes('Controller is already closed')) {
                            console.log('[Reconnect] Stream closed by client');
                            streamClosed = true;
                            return false;
                        }
                        throw error;
                    }
                };
                try {
                    // Send init event with existing content
                    console.log('[Reconnect] Sending init with existing content');
                    if (!safeEnqueue(encoder.encode(`data: ${JSON.stringify({
                        type: 'init',
                        messageId,
                        conversationId: existingState.conversationId,
                        existingContent: existingState.content || ''
                    })}\n\n`))) {
                        return;
                    }
                    // If already completed, send complete event and close
                    if (existingState.status === 'completed') {
                        console.log('[Reconnect] Generation already completed');
                        safeEnqueue(encoder.encode(`data: ${JSON.stringify({
                            type: 'complete',
                            metadata: existingState.metadata
                        })}\n\n`));
                        safeEnqueue(encoder.encode('data: [DONE]\n\n'));
                        if (!streamClosed) controller.close();
                        return;
                    }
                    // If failed, send error and close
                    if (existingState.status === 'error') {
                        console.log('[Reconnect] Generation failed:', existingState.error);
                        safeEnqueue(encoder.encode(`data: ${JSON.stringify({
                            type: 'error',
                            error: existingState.error || 'Generation failed'
                        })}\n\n`));
                        safeEnqueue(encoder.encode('data: [DONE]\n\n'));
                        if (!streamClosed) controller.close();
                        return;
                    }
                    // Still generating - subscribe to pub/sub for remaining events
                    console.log('[Reconnect] Subscribing to pub/sub for remaining events');
                    const messageStream = red.messageQueue.subscribeToMessage(messageId);
                    for await (const event of messageStream){
                        if (streamClosed) {
                            console.log('[Reconnect] Stream closed, stopping subscription');
                            break;
                        }
                        console.log('[Reconnect] Received event:', event.type);
                        if (event.type === 'chunk') {
                            if (!safeEnqueue(encoder.encode(`data: ${JSON.stringify({
                                type: 'content',
                                content: event.content
                            })}\n\n`))) break;
                        } else if (event.type === 'status') {
                            if (!safeEnqueue(encoder.encode(`data: ${JSON.stringify({
                                type: 'status',
                                action: event.action,
                                description: event.description
                            })}\n\n`))) break;
                        } else if (event.type === 'thinking_chunk') {
                            if (!safeEnqueue(encoder.encode(`data: ${JSON.stringify({
                                type: 'thinking_chunk',
                                content: event.content
                            })}\n\n`))) break;
                        } else if (event.type === 'thinking') {
                            if (!safeEnqueue(encoder.encode(`data: ${JSON.stringify({
                                type: 'thinking',
                                content: event.content
                            })}\n\n`))) break;
                        } else if (event.type === 'tool_status') {
                            if (!safeEnqueue(encoder.encode(`data: ${JSON.stringify({
                                type: 'tool_status',
                                status: event.status,
                                action: event.action
                            })}\n\n`))) break;
                        } else if (event.type === 'complete') {
                            safeEnqueue(encoder.encode(`data: ${JSON.stringify({
                                type: 'complete',
                                metadata: event.metadata
                            })}\n\n`));
                            break;
                        } else if (event.type === 'error') {
                            safeEnqueue(encoder.encode(`data: ${JSON.stringify({
                                type: 'error',
                                error: event.error
                            })}\n\n`));
                            break;
                        }
                    }
                    safeEnqueue(encoder.encode('data: [DONE]\n\n'));
                    if (!streamClosed) controller.close();
                } catch (error) {
                    console.error('[Reconnect] Stream error:', error);
                    if (!streamClosed) {
                        safeEnqueue(encoder.encode(`data: ${JSON.stringify({
                            type: 'error',
                            error: error instanceof Error ? error.message : String(error)
                        })}\n\n`));
                        controller.close();
                    }
                }
            }
        });
        return new Response(stream, {
            headers: {
                'Content-Type': 'text/event-stream',
                'Cache-Control': 'no-cache, no-transform',
                'Connection': 'keep-alive',
                'X-Accel-Buffering': 'no'
            }
        });
    } catch (error) {
        console.error('[Reconnect] Error:', error);
        return new Response(JSON.stringify({
            error: error instanceof Error ? error.message : String(error)
        }), {
            status: 500,
            headers: {
                'Content-Type': 'application/json'
            }
        });
    }
}
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__f2480953._.js.map