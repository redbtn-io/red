module.exports = [
"[project]/node_modules/@redbtn/ai/dist/lib/utils/tokenizer.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * @file src/lib/tokenizer.ts
 * @description Token counting with fallback for environments where tiktoken doesn't work
 */ var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.countTokens = countTokens;
exports.freeTiktoken = freeTiktoken;
exports.isTiktokenAvailable = isTiktokenAvailable;
let tiktokenEncoder = null;
let tiktokenAvailable = false;
let initAttempted = false;
/**
 * Initialize tiktoken encoder lazily
 */ function initTiktoken() {
    return __awaiter(this, void 0, void 0, function*() {
        if (tiktokenEncoder !== null) {
            return tiktokenEncoder;
        }
        // Only attempt initialization once
        if (initAttempted) {
            return null;
        }
        initAttempted = true;
        try {
            // Try to load tiktoken
            const { encoding_for_model } = yield Promise.resolve().then(()=>__importStar(__turbopack_context__.r("[project]/node_modules/tiktoken/tiktoken.cjs [app-route] (ecmascript)")));
            tiktokenEncoder = encoding_for_model('gpt-4');
            tiktokenAvailable = true;
            console.log('[Tokenizer] tiktoken loaded successfully');
            return tiktokenEncoder;
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            console.warn('[Tokenizer] tiktoken not available, using fallback token estimation (1 token ≈ 4 chars)');
            tiktokenAvailable = false;
            return null;
        }
    });
}
/**
 * Count tokens using tiktoken or fallback estimation
 */ function countTokens(text) {
    return __awaiter(this, void 0, void 0, function*() {
        try {
            const encoder = yield initTiktoken();
            if (encoder && tiktokenAvailable) {
                return encoder.encode(text).length;
            }
        } catch (error) {
            console.warn('[Tokenizer] Error using tiktoken, falling back to estimation');
        }
        // Fallback: rough estimate (1 token ≈ 4 characters)
        return Math.ceil(text.length / 4);
    });
}
/**
 * Free tiktoken encoder resources
 */ function freeTiktoken() {
    if (tiktokenEncoder && tiktokenAvailable) {
        try {
            tiktokenEncoder.free();
        } catch (error) {
        // Ignore errors during cleanup
        }
    }
    tiktokenEncoder = null;
    tiktokenAvailable = false;
}
/**
 * Check if tiktoken is available
 */ function isTiktokenAvailable() {
    return tiktokenAvailable;
}
}),
"[project]/node_modules/@redbtn/ai/dist/lib/memory/database.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DatabaseManager = void 0;
exports.getDatabase = getDatabase;
exports.resetDatabase = resetDatabase;
const mongodb_1 = __turbopack_context__.r("[externals]/mongodb [external] (mongodb, cjs)");
// ============================================================================
// DATABASE MANAGER CLASS
// ============================================================================
/**
 * Universal database manager for MongoDB operations
 * Supports messages, conversations, logs, generations, and generic collections
 */ class DatabaseManager {
    constructor(mongoUrl = 'mongodb://localhost:27017', dbName = 'redbtn_ai'){
        this.mongoUrl = mongoUrl;
        this.dbName = dbName;
        this.client = null;
        this.db = null;
        this.collections = new Map();
        this.connectionPromise = null;
        // Pre-defined collection names
        this.COLLECTIONS = {
            MESSAGES: 'messages',
            CONVERSATIONS: 'conversations',
            LOGS: 'logs',
            GENERATIONS: 'generations',
            THOUGHTS: 'thoughts'
        };
    }
    // ==========================================================================
    // CONNECTION MANAGEMENT
    // ==========================================================================
    // ==========================================================================
    // CONNECTION MANAGEMENT
    // ==========================================================================
    /**
     * Connect to MongoDB and initialize collections
     */ connect() {
        return __awaiter(this, void 0, void 0, function*() {
            if (this.connectionPromise) {
                return this.connectionPromise;
            }
            this.connectionPromise = (()=>__awaiter(this, void 0, void 0, function*() {
                    try {
                        console.log('[Database] Connecting to MongoDB...');
                        // Connection options
                        const options = {
                            authMechanism: undefined,
                            authSource: 'admin'
                        };
                        // If URL contains username/password, set auth source
                        if (this.mongoUrl.includes('@')) {
                            options.authSource = 'admin';
                        }
                        this.client = new mongodb_1.MongoClient(this.mongoUrl, {
                            serverSelectionTimeoutMS: 5000,
                            connectTimeoutMS: 10000
                        });
                        yield this.client.connect();
                        // Test the connection
                        yield this.client.db('admin').admin().ping();
                        this.db = this.client.db(this.dbName);
                        // Initialize core collections
                        yield this.initializeCollections();
                        console.log('[Database] Connected to MongoDB successfully');
                    } catch (error) {
                        console.error('[Database] Failed to connect to MongoDB:', error);
                        console.error('[Database] Make sure MongoDB is running and authentication is configured correctly');
                        console.error('[Database] Current connection string:', this.mongoUrl.replace(/\/\/([^:]+):([^@]+)@/, '//$1:****@'));
                        this.connectionPromise = null;
                        throw error;
                    }
                }))();
            return this.connectionPromise;
        });
    }
    /**
     * Initialize collections with indexes
     */ initializeCollections() {
        return __awaiter(this, void 0, void 0, function*() {
            if (!this.db) throw new Error('Database not connected');
            // Messages collection
            const messages = this.db.collection(this.COLLECTIONS.MESSAGES);
            yield messages.createIndex({
                conversationId: 1,
                timestamp: 1
            });
            yield messages.createIndex({
                timestamp: -1
            });
            this.collections.set(this.COLLECTIONS.MESSAGES, messages);
            // Conversations collection
            const conversations = this.db.collection(this.COLLECTIONS.CONVERSATIONS);
            yield conversations.createIndex({
                conversationId: 1
            }, {
                unique: true
            });
            yield conversations.createIndex({
                updatedAt: -1
            });
            yield conversations.createIndex({
                userId: 1
            });
            this.collections.set(this.COLLECTIONS.CONVERSATIONS, conversations);
            // Logs collection with 6-month TTL
            const logs = this.db.collection(this.COLLECTIONS.LOGS);
            yield logs.createIndex({
                timestamp: -1
            });
            yield logs.createIndex({
                generationId: 1
            });
            yield logs.createIndex({
                conversationId: 1
            });
            yield logs.createIndex({
                level: 1
            });
            yield logs.createIndex({
                category: 1
            });
            yield logs.createIndex({
                logId: 1
            }, {
                unique: true
            });
            // TTL index: automatically delete logs after 6 months (15552000 seconds)
            yield logs.createIndex({
                timestamp: 1
            }, {
                expireAfterSeconds: 15552000
            });
            this.collections.set(this.COLLECTIONS.LOGS, logs);
            // Generations collection
            const generations = this.db.collection(this.COLLECTIONS.GENERATIONS);
            yield generations.createIndex({
                generationId: 1
            }, {
                unique: true
            });
            yield generations.createIndex({
                conversationId: 1
            });
            yield generations.createIndex({
                status: 1
            });
            yield generations.createIndex({
                startTime: -1
            });
            yield generations.createIndex({
                nodeId: 1
            });
            this.collections.set(this.COLLECTIONS.GENERATIONS, generations);
            // Thoughts collection (stores thinking/reasoning separately from messages)
            const thoughts = this.db.collection(this.COLLECTIONS.THOUGHTS);
            yield thoughts.createIndex({
                thoughtId: 1
            }, {
                unique: true
            });
            yield thoughts.createIndex({
                conversationId: 1
            });
            yield thoughts.createIndex({
                messageId: 1
            });
            yield thoughts.createIndex({
                generationId: 1
            });
            yield thoughts.createIndex({
                timestamp: -1
            });
            yield thoughts.createIndex({
                source: 1
            });
            this.collections.set(this.COLLECTIONS.THOUGHTS, thoughts);
        });
    }
    /**
     * Ensure connection is established
     */ ensureConnected() {
        return __awaiter(this, void 0, void 0, function*() {
            if (!this.db || this.collections.size === 0) {
                yield this.connect();
            }
        });
    }
    /**
     * Get a collection by name (with type safety)
     */ getCollection(name) {
        const collection = this.collections.get(name);
        if (!collection) {
            throw new Error(`Collection ${name} not initialized`);
        }
        return collection;
    }
    /**
     * Get or create a custom collection
     */ collection(name) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.ensureConnected();
            if (!this.collections.has(name)) {
                const col = this.db.collection(name);
                this.collections.set(name, col);
            }
            return this.getCollection(name);
        });
    }
    // ==========================================================================
    // GENERIC CRUD OPERATIONS
    // ==========================================================================
    /**
     * Insert a single document into any collection
     */ insertOne(collectionName, document) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.ensureConnected();
            const col = yield this.collection(collectionName);
            const doc = Object.assign(Object.assign({}, document), {
                createdAt: document.createdAt || new Date(),
                updatedAt: document.updatedAt || new Date()
            });
            const result = yield col.insertOne(doc);
            return result.insertedId;
        });
    }
    /**
     * Insert multiple documents into any collection
     */ insertMany(collectionName, documents) {
        return __awaiter(this, void 0, void 0, function*() {
            if (documents.length === 0) return [];
            yield this.ensureConnected();
            const col = yield this.collection(collectionName);
            const docs = documents.map((doc)=>Object.assign(Object.assign({}, doc), {
                    createdAt: doc.createdAt || new Date(),
                    updatedAt: doc.updatedAt || new Date()
                }));
            const result = yield col.insertMany(docs);
            return Object.values(result.insertedIds);
        });
    }
    /**
     * Find documents in any collection
     */ find(collectionName_1) {
        return __awaiter(this, arguments, void 0, function*(collectionName, filter = {}, options) {
            yield this.ensureConnected();
            const col = yield this.collection(collectionName);
            return yield col.find(filter, options).toArray();
        });
    }
    /**
     * Find a single document in any collection
     */ findOne(collectionName, filter) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.ensureConnected();
            const col = yield this.collection(collectionName);
            return yield col.findOne(filter);
        });
    }
    /**
     * Update documents in any collection
     */ updateMany(collectionName, filter, update) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.ensureConnected();
            const col = yield this.collection(collectionName);
            // Add updatedAt timestamp
            const updateWithTimestamp = Object.assign(Object.assign({}, update), {
                $set: Object.assign(Object.assign({}, update.$set || {}), {
                    updatedAt: new Date()
                })
            });
            const result = yield col.updateMany(filter, updateWithTimestamp);
            return result.modifiedCount;
        });
    }
    /**
     * Update a single document in any collection
     */ updateOne(collectionName_1, filter_1, update_1) {
        return __awaiter(this, arguments, void 0, function*(collectionName, filter, update, upsert = false) {
            yield this.ensureConnected();
            const col = yield this.collection(collectionName);
            // Add updatedAt timestamp
            const updateWithTimestamp = Object.assign(Object.assign({}, update), {
                $set: Object.assign(Object.assign({}, update.$set || {}), {
                    updatedAt: new Date()
                }),
                $setOnInsert: Object.assign(Object.assign({}, update.$setOnInsert || {}), {
                    createdAt: new Date()
                })
            });
            const result = yield col.updateOne(filter, updateWithTimestamp, {
                upsert
            });
            return result.modifiedCount > 0 || upsert && result.upsertedCount > 0;
        });
    }
    /**
     * Delete documents from any collection
     */ deleteMany(collectionName, filter) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.ensureConnected();
            const col = yield this.collection(collectionName);
            const result = yield col.deleteMany(filter);
            return result.deletedCount;
        });
    }
    /**
     * Delete a single document from any collection
     */ deleteOne(collectionName, filter) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.ensureConnected();
            const col = yield this.collection(collectionName);
            const result = yield col.deleteOne(filter);
            return result.deletedCount > 0;
        });
    }
    /**
     * Count documents in any collection
     */ count(collectionName_1) {
        return __awaiter(this, arguments, void 0, function*(collectionName, filter = {}) {
            yield this.ensureConnected();
            const col = yield this.collection(collectionName);
            return yield col.countDocuments(filter);
        });
    }
    // ==========================================================================
    // MESSAGE OPERATIONS (Backward Compatible)
    // ==========================================================================
    // ==========================================================================
    // MESSAGE OPERATIONS (Backward Compatible)
    // ==========================================================================
    /**
     * Store a message in the database
     */ storeMessage(message) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.ensureConnected();
            const messagesCol = this.getCollection(this.COLLECTIONS.MESSAGES);
            const result = yield messagesCol.insertOne(Object.assign(Object.assign({}, message), {
                createdAt: new Date(),
                updatedAt: new Date()
            }));
            // Update conversation's updatedAt timestamp
            const conversationsCol = this.getCollection(this.COLLECTIONS.CONVERSATIONS);
            yield conversationsCol.updateOne({
                conversationId: message.conversationId
            }, {
                $set: {
                    updatedAt: new Date()
                },
                $inc: {
                    'metadata.messageCount': 1
                }
            }, {
                upsert: true
            });
            return result.insertedId;
        });
    }
    /**
     * Store multiple messages in bulk
     */ storeMessages(messages) {
        return __awaiter(this, void 0, void 0, function*() {
            if (messages.length === 0) return;
            yield this.ensureConnected();
            const messagesCol = this.getCollection(this.COLLECTIONS.MESSAGES);
            yield messagesCol.insertMany(messages.map((msg)=>Object.assign(Object.assign({}, msg), {
                    createdAt: new Date(),
                    updatedAt: new Date()
                })));
            // Update conversation timestamp
            const conversationId = messages[0].conversationId;
            const conversationsCol = this.getCollection(this.COLLECTIONS.CONVERSATIONS);
            yield conversationsCol.updateOne({
                conversationId
            }, {
                $set: {
                    updatedAt: new Date()
                },
                $inc: {
                    'metadata.messageCount': messages.length
                }
            }, {
                upsert: true
            });
        });
    }
    /**
     * Get messages for a conversation
     * @param limit - Maximum number of messages to retrieve (0 = all)
     * @param skip - Number of messages to skip (for pagination)
     */ getMessages(conversationId_1) {
        return __awaiter(this, arguments, void 0, function*(conversationId, limit = 0, skip = 0) {
            yield this.ensureConnected();
            const messagesCol = this.getCollection(this.COLLECTIONS.MESSAGES);
            const query = messagesCol.find({
                conversationId
            }).sort({
                timestamp: 1
            }).skip(skip);
            if (limit > 0) {
                query.limit(limit);
            }
            return yield query.toArray();
        });
    }
    /**
     * Get the last N messages for a conversation
     */ getLastMessages(conversationId, count) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.ensureConnected();
            const messagesCol = this.getCollection(this.COLLECTIONS.MESSAGES);
            const messages = yield messagesCol.find({
                conversationId
            }).sort({
                timestamp: -1
            }).limit(count).toArray();
            // Reverse to get chronological order
            return messages.reverse();
        });
    }
    /**
     * Get message count for a conversation
     */ getMessageCount(conversationId) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.ensureConnected();
            const messagesCol = this.getCollection(this.COLLECTIONS.MESSAGES);
            return yield messagesCol.countDocuments({
                conversationId
            });
        });
    }
    // ==========================================================================
    // CONVERSATION OPERATIONS (Backward Compatible)
    // ==========================================================================
    /**
     * Create or update a conversation
     */ upsertConversation(conversation) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.ensureConnected();
            const conversationsCol = this.getCollection(this.COLLECTIONS.CONVERSATIONS);
            yield conversationsCol.updateOne({
                conversationId: conversation.conversationId
            }, {
                $set: Object.assign(Object.assign({}, conversation), {
                    updatedAt: new Date()
                }),
                $setOnInsert: {
                    createdAt: new Date()
                }
            }, {
                upsert: true
            });
        });
    }
    /**
     * Update conversation title
     */ updateConversationTitle(conversationId, title) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.ensureConnected();
            const conversationsCol = this.getCollection(this.COLLECTIONS.CONVERSATIONS);
            yield conversationsCol.updateOne({
                conversationId
            }, {
                $set: {
                    title,
                    updatedAt: new Date()
                }
            });
        });
    }
    /**
     * Get a conversation by ID
     */ getConversation(conversationId) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.ensureConnected();
            const conversationsCol = this.getCollection(this.COLLECTIONS.CONVERSATIONS);
            return yield conversationsCol.findOne({
                conversationId
            });
        });
    }
    /**
     * Get all conversations (sorted by most recent)
     */ getConversations() {
        return __awaiter(this, arguments, void 0, function*(limit = 50, skip = 0) {
            yield this.ensureConnected();
            const conversationsCol = this.getCollection(this.COLLECTIONS.CONVERSATIONS);
            return yield conversationsCol.find({}).sort({
                updatedAt: -1
            }).skip(skip).limit(limit).toArray();
        });
    }
    /**
     * Delete a conversation and all its messages
     */ deleteConversation(conversationId) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.ensureConnected();
            const messagesCol = this.getCollection(this.COLLECTIONS.MESSAGES);
            const conversationsCol = this.getCollection(this.COLLECTIONS.CONVERSATIONS);
            yield messagesCol.deleteMany({
                conversationId
            });
            yield conversationsCol.deleteOne({
                conversationId
            });
        });
    }
    // ==========================================================================
    // LOG OPERATIONS (New)
    // ==========================================================================
    /**
     * Store a log entry
     */ storeLog(log) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.insertOne(this.COLLECTIONS.LOGS, log);
        });
    }
    /**
     * Store multiple log entries
     */ storeLogs(logs) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.insertMany(this.COLLECTIONS.LOGS, logs);
        });
    }
    /**
     * Get logs by generation ID
     */ getLogsByGeneration(generationId, limit) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.ensureConnected();
            const logsCol = this.getCollection(this.COLLECTIONS.LOGS);
            const query = logsCol.find({
                generationId
            }).sort({
                timestamp: 1
            });
            if (limit) query.limit(limit);
            return yield query.toArray();
        });
    }
    /**
     * Get logs by conversation ID
     */ getLogsByConversation(conversationId, limit) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.ensureConnected();
            const logsCol = this.getCollection(this.COLLECTIONS.LOGS);
            const query = logsCol.find({
                conversationId
            }).sort({
                timestamp: -1
            });
            if (limit) query.limit(limit);
            return yield query.toArray();
        });
    }
    /**
     * Get logs by level
     */ getLogsByLevel(level, limit) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.ensureConnected();
            const logsCol = this.getCollection(this.COLLECTIONS.LOGS);
            const query = logsCol.find({
                level
            }).sort({
                timestamp: -1
            });
            if (limit) query.limit(limit);
            return yield query.toArray();
        });
    }
    /**
     * Get logs with filters
     */ getLogs() {
        return __awaiter(this, arguments, void 0, function*(filter = {}, limit = 100, skip = 0) {
            return yield this.find(this.COLLECTIONS.LOGS, filter, {
                sort: {
                    timestamp: -1
                },
                limit,
                skip
            });
        });
    }
    /**
     * Delete old logs (older than specified date)
     */ deleteOldLogs(olderThan) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.deleteMany(this.COLLECTIONS.LOGS, {
                timestamp: {
                    $lt: olderThan
                }
            });
        });
    }
    // ==========================================================================
    // GENERATION OPERATIONS (New)
    // ==========================================================================
    /**
     * Store a generation entry
     */ storeGeneration(generation) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.insertOne(this.COLLECTIONS.GENERATIONS, generation);
        });
    }
    /**
     * Update generation status
     */ updateGenerationStatus(generationId, status, metadata) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.updateOne(this.COLLECTIONS.GENERATIONS, {
                generationId
            }, {
                $set: Object.assign(Object.assign({
                    status
                }, status === 'completed' || status === 'failed' ? {
                    endTime: new Date()
                } : {}), metadata)
            });
        });
    }
    /**
     * Get a generation by ID
     */ getGeneration(generationId) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.findOne(this.COLLECTIONS.GENERATIONS, {
                generationId
            });
        });
    }
    /**
     * Get generations by conversation ID
     */ getGenerationsByConversation(conversationId, limit) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.find(this.COLLECTIONS.GENERATIONS, {
                conversationId
            }, {
                sort: {
                    startTime: -1
                },
                limit
            });
        });
    }
    /**
     * Get active generations (pending or streaming)
     */ getActiveGenerations() {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.find(this.COLLECTIONS.GENERATIONS, {
                status: {
                    $in: [
                        'pending',
                        'streaming'
                    ]
                }
            }, {
                sort: {
                    startTime: -1
                }
            });
        });
    }
    /**
     * Delete old generations (older than specified date)
     */ deleteOldGenerations(olderThan) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.deleteMany(this.COLLECTIONS.GENERATIONS, {
                startTime: {
                    $lt: olderThan
                },
                status: {
                    $in: [
                        'completed',
                        'failed'
                    ]
                }
            });
        });
    }
    // ==========================================================================
    // THOUGHT OPERATIONS
    // ==========================================================================
    /**
     * Store a thought/reasoning entry
     */ storeThought(thought) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.insertOne(this.COLLECTIONS.THOUGHTS, thought);
        });
    }
    /**
     * Store multiple thoughts in bulk
     */ storeThoughts(thoughts) {
        return __awaiter(this, void 0, void 0, function*() {
            if (thoughts.length === 0) return;
            yield this.insertMany(this.COLLECTIONS.THOUGHTS, thoughts);
        });
    }
    /**
     * Get thought by ID
     */ getThought(thoughtId) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.findOne(this.COLLECTIONS.THOUGHTS, {
                thoughtId
            });
        });
    }
    /**
     * Get thoughts for a specific message
     */ getThoughtsByMessage(messageId) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.find(this.COLLECTIONS.THOUGHTS, {
                messageId
            }, {
                sort: {
                    timestamp: 1
                }
            });
        });
    }
    /**
     * Get thoughts for a conversation
     */ getThoughtsByConversation(conversationId, limit) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.find(this.COLLECTIONS.THOUGHTS, {
                conversationId
            }, {
                sort: {
                    timestamp: -1
                },
                limit
            });
        });
    }
    /**
     * Get thoughts for a generation
     */ getThoughtsByGeneration(generationId) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.find(this.COLLECTIONS.THOUGHTS, {
                generationId
            }, {
                sort: {
                    timestamp: 1
                }
            });
        });
    }
    /**
     * Get thoughts by source (chat, router, toolPicker)
     */ getThoughtsBySource(source, conversationId, limit) {
        return __awaiter(this, void 0, void 0, function*() {
            const filter = {
                source
            };
            if (conversationId) {
                filter.conversationId = conversationId;
            }
            return yield this.find(this.COLLECTIONS.THOUGHTS, filter, {
                sort: {
                    timestamp: -1
                },
                limit
            });
        });
    }
    /**
     * Delete old thoughts (older than specified date)
     */ deleteOldThoughts(olderThan) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.deleteMany(this.COLLECTIONS.THOUGHTS, {
                timestamp: {
                    $lt: olderThan
                }
            });
        });
    }
    // ==========================================================================
    // CONNECTION MANAGEMENT
    // ==========================================================================
    /**
     * Close database connection
     */ close() {
        return __awaiter(this, void 0, void 0, function*() {
            if (this.client) {
                yield this.client.close();
                this.client = null;
                this.db = null;
                this.collections.clear();
                this.connectionPromise = null;
                console.log('[Database] Closed MongoDB connection');
            }
        });
    }
}
exports.DatabaseManager = DatabaseManager;
// ============================================================================
// SINGLETON & EXPORTS
// ============================================================================
// Singleton instance
let dbInstance = null;
/**
 * Get the singleton database instance
 * @param mongoUrl - MongoDB connection URL (default: from env or localhost)
 * @param dbName - Database name (default: from env or 'redbtn_ai')
 */ function getDatabase(mongoUrl, dbName) {
    if (!dbInstance) {
        // Support both MONGODB_URI and MONGODB_URL
        const envUri = process.env.MONGODB_URI || process.env.MONGODB_URL || 'mongodb://localhost:27017';
        const url = mongoUrl || envUri;
        // Try to extract database name from URI if present
        let name = dbName;
        if (!name) {
            // Parse database name from URI like mongodb://user:pass@host:port/dbname
            const dbMatch = url.match(/\/([^/?]+)(\?|$)/);
            if (dbMatch && dbMatch[1]) {
                name = dbMatch[1];
            } else {
                name = process.env.MONGODB_NAME || 'redbtn_ai';
            }
        }
        dbInstance = new DatabaseManager(url, name);
    }
    return dbInstance;
}
/**
 * Reset the singleton instance (useful for testing)
 */ function resetDatabase() {
    dbInstance = null;
}
}),
"[project]/node_modules/@redbtn/ai/dist/lib/memory/memory.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * @file src/lib/memory.ts
 * @description Conversation memory management with MongoDB persistence and Redis caching
 */ var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MemoryManager = void 0;
const ioredis_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/ioredis/built/index.js [app-route] (ecmascript)"));
const tokenizer_1 = __turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/lib/utils/tokenizer.js [app-route] (ecmascript)");
const database_1 = __turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/lib/memory/database.js [app-route] (ecmascript)");
class MemoryManager {
    constructor(redisUrl){
        this.MAX_CONTEXT_TOKENS = parseInt(process.env.MAX_CONTEXT_TOKENS || '30000');
        this.SUMMARY_CUSHION_TOKENS = parseInt(process.env.SUMMARY_CUSHION_TOKENS || '2000');
        this.REDIS_MESSAGE_LIMIT = 100; // Keep last 100 messages in Redis for hot context
        this.redisUrl = redisUrl;
        this.redis = new ioredis_1.default(redisUrl);
    }
    /**
     * Generate a conversation ID based on initial message content (stable hashing)
     * or create a random ID if no seed is provided
     */ generateConversationId(seedMessage) {
        if (seedMessage) {
            // Create stable ID based on message content
            const crypto = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)");
            const hash = crypto.createHash('sha256').update(seedMessage).digest('hex').substring(0, 16);
            return `conv_${hash}`;
        }
        // Generate random ID for one-off conversations
        const crypto = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)");
        return `conv_${crypto.randomBytes(8).toString('hex')}`;
    }
    /**
     * Count tokens in a message
     */ countMessageTokens(message) {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                // Format: role + content + overhead (4 tokens per message for formatting)
                const roleTokens = yield (0, tokenizer_1.countTokens)(message.role);
                const contentTokens = yield (0, tokenizer_1.countTokens)(message.content);
                return roleTokens + contentTokens + 4;
            } catch (error) {
                // Fallback: rough estimate (1 token ≈ 4 characters)
                return Math.ceil((message.role.length + message.content.length) / 4);
            }
        });
    }
    /**
     * Count tokens in multiple messages
     */ countMessagesTokens(messages) {
        return __awaiter(this, void 0, void 0, function*() {
            let total = 0;
            for (const msg of messages){
                total += yield this.countMessageTokens(msg);
            }
            return total;
        });
    }
    /**
     * Get conversation context: returns messages that fit within token limit.
     * Use getContextSummary() separately to retrieve summary for merging with system prompts.
     */ getContextForConversation(conversationId) {
        return __awaiter(this, void 0, void 0, function*() {
            const messages = yield this.getMessages(conversationId);
            // Calculate tokens and return messages that fit within limit
            let totalTokens = 0;
            const recentMessages = [];
            // Work backwards from most recent message
            for(let i = messages.length - 1; i >= 0; i--){
                const msgTokens = yield this.countMessageTokens(messages[i]);
                if (totalTokens + msgTokens <= this.MAX_CONTEXT_TOKENS) {
                    recentMessages.unshift(messages[i]);
                    totalTokens += msgTokens;
                } else {
                    break;
                }
            }
            return recentMessages;
        });
    }
    /**
     * Get conversation summary (if exists) for manual inclusion in system prompts.
     * Returns null if no summary has been generated yet.
     * This returns the TRAILING summary (old trimmed messages).
     */ getContextSummary(conversationId) {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.getTrailingSummary(conversationId);
        });
    }
    /**
     * Add a new message to the conversation
     * Stores in both MongoDB (persistence) and Redis (hot cache of last 100 messages)
     */ addMessage(conversationId, message) {
        return __awaiter(this, void 0, void 0, function*() {
            const key = `conversations:${conversationId}:messages`;
            // Store in MongoDB for persistence (non-blocking, ignore errors)
            (0, database_1.getDatabase)().storeMessage({
                conversationId,
                role: message.role,
                content: message.content,
                timestamp: new Date(message.timestamp),
                metadata: {}
            }).catch((err)=>{
                console.warn('[Memory] Failed to save message to MongoDB:', err.message);
            });
            // Add to Redis (hot cache)
            yield this.redis.rpush(key, JSON.stringify(message));
            // Trim Redis to keep only last 100 messages
            const messageCount = yield this.redis.llen(key);
            if (messageCount > this.REDIS_MESSAGE_LIMIT) {
                const trimCount = messageCount - this.REDIS_MESSAGE_LIMIT;
                yield this.redis.ltrim(key, trimCount, -1);
                console.log(`[Memory] Trimmed ${trimCount} old messages from Redis cache for ${conversationId}`);
            }
            // Update metadata
            yield this.updateMetadata(conversationId);
        });
    }
    /**
     * Get all messages for a conversation from MongoDB (full history)
     * For recent hot context, messages are served from Redis cache
     */ getMessages(conversationId) {
        return __awaiter(this, void 0, void 0, function*() {
            // Try Redis first (hot cache - last 100 messages)
            const key = `conversations:${conversationId}:messages`;
            const messagesJson = yield this.redis.lrange(key, 0, -1);
            if (messagesJson.length > 0) {
                return messagesJson.map((json)=>JSON.parse(json));
            }
            // If not in Redis, try to fetch from MongoDB and populate Redis
            try {
                const db = (0, database_1.getDatabase)();
                const dbMessages = yield db.getLastMessages(conversationId, this.REDIS_MESSAGE_LIMIT);
                if (dbMessages.length > 0) {
                    // Populate Redis cache
                    const pipeline = this.redis.pipeline();
                    for (const msg of dbMessages){
                        const convMsg = {
                            role: msg.role,
                            content: msg.content,
                            timestamp: msg.timestamp.getTime()
                        };
                        pipeline.rpush(key, JSON.stringify(convMsg));
                    }
                    yield pipeline.exec();
                    console.log(`[Memory] Populated Redis cache with ${dbMessages.length} messages from MongoDB for ${conversationId}`);
                    return dbMessages.map((msg)=>({
                            role: msg.role,
                            content: msg.content,
                            timestamp: msg.timestamp.getTime()
                        }));
                }
            } catch (error) {
                console.warn('[Memory] Failed to fetch from MongoDB:', error instanceof Error ? error.message : String(error));
            }
            return [];
        });
    }
    /**
     * Get all messages from MongoDB (for full conversation history)
     */ getAllMessagesFromDB(conversationId) {
        return __awaiter(this, void 0, void 0, function*() {
            const db = (0, database_1.getDatabase)();
            const dbMessages = yield db.getMessages(conversationId);
            return dbMessages.map((msg)=>({
                    role: msg.role,
                    content: msg.content,
                    timestamp: msg.timestamp.getTime()
                }));
        });
    }
    /**
     * Get trailing summary (old trimmed messages)
     */ getTrailingSummary(conversationId) {
        return __awaiter(this, void 0, void 0, function*() {
            const key = `conversations:${conversationId}:summary:trailing`;
            return yield this.redis.get(key);
        });
    }
    /**
     * Store trailing summary (old trimmed messages)
     */ setTrailingSummary(conversationId, summary) {
        return __awaiter(this, void 0, void 0, function*() {
            const summaryKey = `conversations:${conversationId}:summary:trailing`;
            const metaKey = `conversations:${conversationId}:metadata`;
            yield this.redis.set(summaryKey, summary);
            yield this.redis.hset(metaKey, 'trailingSummaryGenerated', 'true');
            yield this.redis.hdel(metaKey, 'needsTrailingSummaryGeneration');
            yield this.redis.hdel(metaKey, 'contentToSummarize');
        });
    }
    /**
     * Get executive summary (full conversation overview)
     */ getExecutiveSummary(conversationId) {
        return __awaiter(this, void 0, void 0, function*() {
            const key = `conversations:${conversationId}:summary:executive`;
            return yield this.redis.get(key);
        });
    }
    /**
     * Store executive summary (full conversation overview)
     */ setExecutiveSummary(conversationId, summary) {
        return __awaiter(this, void 0, void 0, function*() {
            const summaryKey = `conversations:${conversationId}:summary:executive`;
            yield this.redis.set(summaryKey, summary);
            console.log(`[Memory] Updated executive summary for ${conversationId}`);
        });
    }
    /**
     * Get conversation metadata
     */ getMetadata(conversationId) {
        return __awaiter(this, void 0, void 0, function*() {
            const key = `conversations:${conversationId}:metadata`;
            const data = yield this.redis.hgetall(key);
            if (Object.keys(data).length === 0) {
                return null;
            }
            return {
                conversationId,
                messageCount: parseInt(data.messageCount || '0'),
                lastUpdated: parseInt(data.lastUpdated || '0'),
                summaryGenerated: data.summaryGenerated === 'true',
                totalTokens: data.totalTokens ? parseInt(data.totalTokens) : undefined,
                title: data.title || undefined,
                titleSetByUser: data.titleSetByUser === 'true' || undefined
            };
        });
    }
    /**
     * Update conversation metadata
     */ updateMetadata(conversationId) {
        return __awaiter(this, void 0, void 0, function*() {
            const key = `conversations:${conversationId}:metadata`;
            const messageCount = yield this.redis.llen(`conversations:${conversationId}:messages`);
            // Calculate total tokens
            const messages = yield this.getMessages(conversationId);
            const totalTokens = yield this.countMessagesTokens(messages);
            yield this.redis.hset(key, {
                messageCount: messageCount.toString(),
                lastUpdated: Date.now().toString(),
                totalTokens: totalTokens.toString()
            });
        });
    }
    /**
     * Check if conversation needs summarization and trimming.
     * Returns true when total tokens exceed MAX_CONTEXT_TOKENS + SUMMARY_CUSHION_TOKENS.
     */ needsSummarization(conversationId) {
        return __awaiter(this, void 0, void 0, function*() {
            const messages = yield this.getMessages(conversationId);
            const totalTokens = yield this.countMessagesTokens(messages);
            // Trigger summarization when we exceed the context limit + cushion
            return totalTokens > this.MAX_CONTEXT_TOKENS + this.SUMMARY_CUSHION_TOKENS;
        });
    }
    /**
     * Trim messages and generate summary to bring conversation under token limit.
     * This includes any existing summary in the summarization.
     */ trimAndSummarize(conversationId) {
        return __awaiter(this, void 0, void 0, function*() {
            const messages = yield this.getMessages(conversationId);
            const existingSummary = yield this.getTrailingSummary(conversationId);
            // Calculate how many tokens we need to keep for recent context
            let recentTokens = 0;
            let keepFromIndex = messages.length;
            // Work backwards to find where to cut
            for(let i = messages.length - 1; i >= 0; i--){
                const msgTokens = yield this.countMessageTokens(messages[i]);
                if (recentTokens + msgTokens <= this.MAX_CONTEXT_TOKENS) {
                    recentTokens += msgTokens;
                    keepFromIndex = i;
                } else {
                    break;
                }
            }
            // If all messages fit, no need to summarize
            if (keepFromIndex === 0) {
                return;
            }
            // Messages to summarize (everything before keepFromIndex)
            const messagesToSummarize = messages.slice(0, keepFromIndex);
            if (messagesToSummarize.length === 0) {
                return;
            }
            // Keep only recent messages in Redis
            const messagesToKeep = messages.slice(keepFromIndex);
            // Clear old messages and store only recent ones
            const messagesKey = `conversations:${conversationId}:messages`;
            yield this.redis.del(messagesKey);
            for (const msg of messagesToKeep){
                yield this.redis.rpush(messagesKey, JSON.stringify(msg));
            }
            // Build summary content (include existing summary if present)
            let contentToSummarize = '';
            if (existingSummary) {
                contentToSummarize += `Previous summary: ${existingSummary}\n\n`;
            }
            contentToSummarize += messagesToSummarize.map((m)=>`${m.role.toUpperCase()}: ${m.content}`).join('\n');
            // Return the content to summarize (caller will invoke LLM)
            // Store a marker that we need to generate trailing summary
            const metaKey = `conversations:${conversationId}:metadata`;
            yield this.redis.hset(metaKey, 'needsTrailingSummaryGeneration', 'true');
            yield this.redis.hset(metaKey, 'contentToSummarize', contentToSummarize);
            // Update metadata
            yield this.updateMetadata(conversationId);
        });
    }
    /**
     * Get content that needs to be summarized (after trimAndSummarize was called)
     */ getContentToSummarize(conversationId) {
        return __awaiter(this, void 0, void 0, function*() {
            const metaKey = `conversations:${conversationId}:metadata`;
            return yield this.redis.hget(metaKey, 'contentToSummarize');
        });
    }
    /**
     * Check if trailing summary generation is pending
     */ needsSummaryGeneration(conversationId) {
        return __awaiter(this, void 0, void 0, function*() {
            const metaKey = `conversations:${conversationId}:metadata`;
            const value = yield this.redis.hget(metaKey, 'needsTrailingSummaryGeneration');
            return value === 'true';
        });
    }
    /**
     * Perform summarization if needed - complete workflow in one call.
     * @param conversationId The conversation to check and summarize
     * @param llmInvoker A function that takes a prompt and returns the LLM's response
     * @returns true if summarization was performed, false if not needed
     */ summarizeIfNeeded(conversationId, llmInvoker) {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                const needsSummary = yield this.needsSummarization(conversationId);
                if (!needsSummary) {
                    return false;
                }
                const tokenCount = yield this.getTokenCount(conversationId);
                console.log(`[Memory] Token limit exceeded for ${conversationId}: ${tokenCount} tokens - trimming and summarizing...`);
                // Trim messages to fit within token limit
                yield this.trimAndSummarize(conversationId);
                // Check if summary generation is needed
                const needsGeneration = yield this.needsSummaryGeneration(conversationId);
                if (!needsGeneration) {
                    console.log(`[Memory] No summary generation needed for ${conversationId}`);
                    return false;
                }
                // Get content to summarize (includes previous summary if exists)
                const contentToSummarize = yield this.getContentToSummarize(conversationId);
                if (!contentToSummarize) {
                    return false;
                }
                // Create summary prompt
                const summaryPrompt = this.buildSummaryPrompt(contentToSummarize);
                // Generate summary using the provided LLM invoker
                const summary = yield llmInvoker(summaryPrompt);
                // Store the trailing summary
                yield this.setTrailingSummary(conversationId, summary);
                const newTokenCount = yield this.getTokenCount(conversationId);
                console.log(`[Memory] Summarization complete for ${conversationId}: trimmed to ${newTokenCount} tokens`);
                return true;
            } catch (error) {
                console.error('[Memory] Summarization error:', error);
                return false;
            }
        });
    }
    /**
     * Generate executive summary (full conversation overview).
     * Should be called after 3rd+ AI responses.
     * @param llmInvoker A function that takes a prompt and returns the LLM's response
     */ generateExecutiveSummary(conversationId, llmInvoker) {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                const messages = yield this.getMessages(conversationId);
                if (messages.length === 0) {
                    return;
                }
                // Build full conversation text
                const conversationText = messages.map((m)=>`${m.role.toUpperCase()}: ${m.content}`).join('\n');
                const prompt = `Provide a comprehensive executive summary of the following conversation. Focus on:
- User's goals and preferences
- Key topics discussed
- Important decisions or conclusions
- Context that would be useful for future interactions

Keep it concise but informative (200-400 words). Only respond with the summary itself:

${conversationText}`;
                const summary = yield llmInvoker(prompt);
                yield this.setExecutiveSummary(conversationId, summary);
                console.log(`[Memory] Generated executive summary for ${conversationId}`);
            } catch (error) {
                console.error('[Memory] Executive summary generation error:', error);
            }
        });
    }
    /**
     * Build the prompt for summarization (can be overridden or customized)
     */ buildSummaryPrompt(contentToSummarize) {
        return `Summarize the following conversation history concisely. Focus on information about the user, key topics, decisions, and important context. Retain key information from previous summaries if they exist. Only respond with the summary itself. Keep it over 500 but under 1000 words:

${contentToSummarize}`;
    }
    /**
     * Get current token count for a conversation (useful for monitoring)
     */ getTokenCount(conversationId) {
        return __awaiter(this, void 0, void 0, function*() {
            const messages = yield this.getMessages(conversationId);
            return yield this.countMessagesTokens(messages);
        });
    }
    /**
     * Get token count for messages that would be returned by getContextForConversation
     */ getContextTokenCount(conversationId) {
        return __awaiter(this, void 0, void 0, function*() {
            const contextMessages = yield this.getContextForConversation(conversationId);
            return yield this.countMessagesTokens(contextMessages);
        });
    }
    /**
     * Delete a conversation (for cleanup/testing)
     */ deleteConversation(conversationId) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.redis.del(`conversations:${conversationId}:messages`);
            yield this.redis.del(`conversations:${conversationId}:summary:trailing`);
            yield this.redis.del(`conversations:${conversationId}:summary:executive`);
            yield this.redis.del(`conversations:${conversationId}:metadata`);
        });
    }
    /**
     * Close Redis connection and free tokenizer
     */ close() {
        return __awaiter(this, void 0, void 0, function*() {
            (0, tokenizer_1.freeTiktoken)();
            yield this.redis.quit();
        });
    }
}
exports.MemoryManager = MemoryManager;
}),
"[project]/node_modules/@redbtn/ai/dist/lib/memory/queue.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
};
var __asyncGenerator = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
    }, i;
    //TURBOPACK unreachable
    ;
    function awaitReturn(f) {
        return function(v) {
            return Promise.resolve(v).then(f, reject);
        };
    }
    function verb(n, f) {
        if (g[n]) {
            i[n] = function(v) {
                return new Promise(function(a, b) {
                    q.push([
                        n,
                        v,
                        a,
                        b
                    ]) > 1 || resume(n, v);
                });
            };
            if (f) i[n] = f(i[n]);
        }
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
};
var __asyncValues = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__asyncValues || function(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
    //TURBOPACK unreachable
    ;
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MessageQueue = void 0;
class MessageQueue {
    constructor(redis){
        this.STATE_TTL = 3600; // 1 hour TTL for message states
        this.CONTENT_KEY_PREFIX = 'message:generating:';
        this.INDEX_KEY_PREFIX = 'conversation:generating:';
        this.PUBSUB_PREFIX = 'message:stream:';
        this.redis = redis;
    }
    /**
     * Start tracking a new message generation
     */ startGeneration(conversationId, messageId) {
        return __awaiter(this, void 0, void 0, function*() {
            const state = {
                conversationId,
                messageId,
                status: 'generating',
                content: '',
                startedAt: Date.now()
            };
            const key = `${this.CONTENT_KEY_PREFIX}${messageId}`;
            yield this.redis.setex(key, this.STATE_TTL, JSON.stringify(state));
            // Add to conversation's generating messages index
            yield this.redis.sadd(`${this.INDEX_KEY_PREFIX}${conversationId}`, messageId);
            yield this.redis.expire(`${this.INDEX_KEY_PREFIX}${conversationId}`, this.STATE_TTL);
            console.log(`[MessageQueue] Started generation tracking: ${messageId}`);
        });
    }
    /**
     * Append content to a generating message (called as tokens stream in)
     */ appendContent(messageId, chunk) {
        return __awaiter(this, void 0, void 0, function*() {
            const key = `${this.CONTENT_KEY_PREFIX}${messageId}`;
            const stateJson = yield this.redis.get(key);
            if (!stateJson) {
                console.warn(`[MessageQueue] Cannot append to non-existent message: ${messageId}`);
                return;
            }
            const state = JSON.parse(stateJson);
            state.content += chunk;
            yield this.redis.setex(key, this.STATE_TTL, JSON.stringify(state));
            // Publish chunk to pub/sub channel for real-time streaming
            yield this.redis.publish(`${this.PUBSUB_PREFIX}${messageId}`, JSON.stringify({
                type: 'chunk',
                content: chunk
            }));
        });
    }
    /**
     * Mark message generation as completed
     */ completeGeneration(messageId, metadata) {
        return __awaiter(this, void 0, void 0, function*() {
            const key = `${this.CONTENT_KEY_PREFIX}${messageId}`;
            const stateJson = yield this.redis.get(key);
            if (!stateJson) {
                console.warn(`[MessageQueue] Cannot complete non-existent message: ${messageId}`);
                return;
            }
            const state = JSON.parse(stateJson);
            state.status = 'completed';
            state.completedAt = Date.now();
            if (metadata) {
                state.metadata = metadata;
            }
            yield this.redis.setex(key, this.STATE_TTL, JSON.stringify(state));
            // Remove from generating index
            yield this.redis.srem(`${this.INDEX_KEY_PREFIX}${state.conversationId}`, messageId);
            // Publish completion event
            yield this.redis.publish(`${this.PUBSUB_PREFIX}${messageId}`, JSON.stringify({
                type: 'complete',
                metadata
            }));
            console.log(`[MessageQueue] Completed generation: ${messageId} (${state.content.length} chars)`);
        });
    }
    /**
     * Publish tool status indicator (searching, scraping, etc.)
     */ publishToolStatus(messageId, toolInfo) {
        return __awaiter(this, void 0, void 0, function*() {
            // Publish tool status event without modifying state
            yield this.redis.publish(`${this.PUBSUB_PREFIX}${messageId}`, JSON.stringify(Object.assign({
                type: 'tool_status'
            }, toolInfo)));
        });
    }
    /**
     * Publish general status update (routing, thinking, processing, etc.)
     */ publishStatus(messageId, status) {
        return __awaiter(this, void 0, void 0, function*() {
            console.log(`[MessageQueue] Publishing status for ${messageId}:`, status.action);
            yield this.redis.publish(`${this.PUBSUB_PREFIX}${messageId}`, JSON.stringify(Object.assign({
                type: 'status'
            }, status)));
        });
    }
    /**
     * Publish thinking/reasoning content chunk by chunk
     */ publishThinkingChunk(messageId, chunk) {
        return __awaiter(this, void 0, void 0, function*() {
            // Silent - too noisy to log each chunk
            yield this.redis.publish(`${this.PUBSUB_PREFIX}${messageId}`, JSON.stringify({
                type: 'thinking_chunk',
                content: chunk
            }));
        });
    }
    /**
     * Publish thinking/reasoning content (legacy - for full blocks)
     */ publishThinking(messageId, thinking) {
        return __awaiter(this, void 0, void 0, function*() {
            // Publish thinking event
            yield this.redis.publish(`${this.PUBSUB_PREFIX}${messageId}`, JSON.stringify({
                type: 'thinking',
                content: thinking
            }));
            console.log(`[MessageQueue] Published thinking for ${messageId} (${thinking.length} chars)`);
        });
    }
    /**
     * Mark message generation as failed
     */ failGeneration(messageId, error) {
        return __awaiter(this, void 0, void 0, function*() {
            const key = `${this.CONTENT_KEY_PREFIX}${messageId}`;
            const stateJson = yield this.redis.get(key);
            if (!stateJson) {
                console.warn(`[MessageQueue] Cannot fail non-existent message: ${messageId}`);
                return;
            }
            const state = JSON.parse(stateJson);
            state.status = 'error';
            state.error = error;
            state.completedAt = Date.now();
            yield this.redis.setex(key, this.STATE_TTL, JSON.stringify(state));
            // Remove from generating index
            yield this.redis.srem(`${this.INDEX_KEY_PREFIX}${state.conversationId}`, messageId);
            // Publish error event
            yield this.redis.publish(`${this.PUBSUB_PREFIX}${messageId}`, JSON.stringify({
                type: 'error',
                error
            }));
            console.error(`[MessageQueue] Failed generation: ${messageId} - ${error}`);
        });
    }
    /**
     * Get current state of a generating message
     */ getMessageState(messageId) {
        return __awaiter(this, void 0, void 0, function*() {
            const key = `${this.CONTENT_KEY_PREFIX}${messageId}`;
            const stateJson = yield this.redis.get(key);
            if (!stateJson) {
                return null;
            }
            return JSON.parse(stateJson);
        });
    }
    /**
     * Get all generating messages for a conversation
     */ getGeneratingMessages(conversationId) {
        return __awaiter(this, void 0, void 0, function*() {
            const messageIds = yield this.redis.smembers(`${this.INDEX_KEY_PREFIX}${conversationId}`);
            if (messageIds.length === 0) {
                return [];
            }
            const states = [];
            for (const messageId of messageIds){
                const state = yield this.getMessageState(messageId);
                if (state) {
                    states.push(state);
                }
            }
            return states;
        });
    }
    /**
     * Clean up completed/failed message state
     */ cleanupMessage(messageId) {
        return __awaiter(this, void 0, void 0, function*() {
            const key = `${this.CONTENT_KEY_PREFIX}${messageId}`;
            yield this.redis.del(key);
        });
    }
    /**
     * Subscribe to a message stream via Redis pub/sub
     * Returns an async generator that yields chunks, completion, or errors
     */ subscribeToMessage(messageId) {
        return __asyncGenerator(this, arguments, function* subscribeToMessage_1() {
            var _a, e_1, _b, _c;
            // First, get any existing content
            const state = yield __await(this.getMessageState(messageId));
            if (!state) {
                throw new Error(`Message ${messageId} not found`);
            }
            // Yield existing content if any
            if (state.content) {
                yield yield __await({
                    type: 'init',
                    existingContent: state.content
                });
            }
            // If already completed, just send completion event
            if (state.status === 'completed') {
                yield yield __await({
                    type: 'complete',
                    metadata: state.metadata
                });
                return yield __await(void 0);
            }
            if (state.status === 'error') {
                yield yield __await({
                    type: 'error',
                    error: state.error
                });
                return yield __await(void 0);
            }
            // Subscribe to pub/sub for new chunks
            const subscriber = this.redis.duplicate();
            // Increase max listeners to prevent warnings when multiple clients connect
            subscriber.setMaxListeners(50);
            const channel = `${this.PUBSUB_PREFIX}${messageId}`;
            const getState = this.getMessageState.bind(this);
            let cleanedUp = false;
            const cleanup = ()=>__awaiter(this, void 0, void 0, function*() {
                    if (cleanedUp) return;
                    cleanedUp = true;
                    try {
                        yield subscriber.unsubscribe(channel);
                        yield subscriber.quit();
                        console.log(`[MessageQueue] Cleaned up subscriber for ${messageId}`);
                    } catch (e) {
                    // Ignore cleanup errors
                    }
                });
            try {
                yield __await(subscriber.subscribe(channel));
                // Create a promise-based message handler
                const messageIterator = function(sub) {
                    return __asyncGenerator(this, arguments, function*() {
                        while(true){
                            const message = yield __await(new Promise((resolve)=>{
                                sub.once('message', (ch, msg)=>{
                                    if (ch === channel) {
                                        resolve(msg);
                                    }
                                });
                                // Timeout after 30 seconds of no activity
                                setTimeout(()=>resolve(null), 30000);
                            }));
                            if (message === null) {
                                // Timeout - check if generation completed
                                const currentState = yield __await(getState(messageId));
                                if (!currentState || currentState.status !== 'generating') {
                                    break;
                                }
                                continue;
                            }
                            yield yield __await(message);
                        }
                    });
                }(subscriber);
                try {
                    for(var _d = true, messageIterator_1 = __asyncValues(messageIterator), messageIterator_1_1; messageIterator_1_1 = yield __await(messageIterator_1.next()), _a = messageIterator_1_1.done, !_a; _d = true){
                        _c = messageIterator_1_1.value;
                        _d = false;
                        const message = _c;
                        const event = JSON.parse(message);
                        if (event.type === 'chunk') {
                            yield yield __await({
                                type: 'chunk',
                                content: event.content
                            });
                        } else if (event.type === 'status') {
                            yield yield __await({
                                type: 'status',
                                action: event.action,
                                description: event.description
                            });
                        } else if (event.type === 'thinking_chunk') {
                            yield yield __await({
                                type: 'thinking_chunk',
                                content: event.content
                            });
                        } else if (event.type === 'thinking') {
                            yield yield __await({
                                type: 'thinking',
                                content: event.content
                            });
                        } else if (event.type === 'tool_status') {
                            yield yield __await({
                                type: 'tool_status',
                                status: event.status,
                                action: event.action
                            });
                        } else if (event.type === 'complete') {
                            yield yield __await({
                                type: 'complete',
                                metadata: event.metadata
                            });
                            break;
                        } else if (event.type === 'error') {
                            yield yield __await({
                                type: 'error',
                                error: event.error
                            });
                            break;
                        }
                    }
                } catch (e_1_1) {
                    e_1 = {
                        error: e_1_1
                    };
                } finally{
                    try {
                        if (!_d && !_a && (_b = messageIterator_1.return)) yield __await(_b.call(messageIterator_1));
                    } finally{
                        if (e_1) throw e_1.error;
                    }
                }
            } finally{
                yield __await(cleanup());
            }
        });
    }
}
exports.MessageQueue = MessageQueue;
}),
"[project]/node_modules/@redbtn/ai/dist/lib/logs/types.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Log types and data structures for the Red AI logging system
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TTL = exports.RedisKeys = void 0;
/**
 * Redis key patterns
 */ exports.RedisKeys = {
    // Log storage
    log: (logId)=>`log:${logId}`,
    generationLogs: (genId)=>`generation:${genId}:logs`,
    conversationLogs: (convId)=>`conversation:${convId}:logs`,
    // Generation tracking
    generation: (genId)=>`generation:${genId}`,
    conversationGeneration: (convId)=>`conversation:${convId}:generation`,
    // Pub/sub channels
    logChannel: (genId)=>`logs:generation:${genId}`,
    conversationLogChannel: (convId)=>`logs:conversation:${convId}`,
    allLogsChannel: 'logs:all'
};
/**
 * TTL values (in seconds)
 */ exports.TTL = {
    LOG: 30 * 24 * 60 * 60,
    GENERATION: 30 * 24 * 60 * 60,
    LOG_LIST: 30 * 24 * 60 * 60
};
}),
"[project]/node_modules/@redbtn/ai/dist/lib/logs/logger.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
};
var __asyncGenerator = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
    }, i;
    //TURBOPACK unreachable
    ;
    function awaitReturn(f) {
        return function(v) {
            return Promise.resolve(v).then(f, reject);
        };
    }
    function verb(n, f) {
        if (g[n]) {
            i[n] = function(v) {
                return new Promise(function(a, b) {
                    q.push([
                        n,
                        v,
                        a,
                        b
                    ]) > 1 || resume(n, v);
                });
            };
            if (f) i[n] = f(i[n]);
        }
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Logger = void 0;
const types_1 = __turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/lib/logs/types.js [app-route] (ecmascript)");
/**
 * The most fantastic logging system known to man
 *
 * Features:
 * - Redis pub/sub for real-time log streaming
 * - 30-day TTL for all logs
 * - Generation-level tracking with unique IDs
 * - Thought logs separate from response logs
 * - Color tag support for frontends
 * - Conversation-level aggregated logs
 * - Concurrent generation prevention
 */ class Logger {
    constructor(redis){
        this.redis = redis;
        // Increase max listeners for pub/sub
        this.redis.setMaxListeners(100);
    }
    /**
     * Generate a unique generation ID
     */ generateGenerationId() {
        const timestamp = Date.now();
        const random = Math.random().toString(36).substring(2, 11);
        return `gen_${timestamp}_${random}`;
    }
    /**
     * Generate a unique log ID
     */ generateLogId() {
        return `log_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;
    }
    /**
     * Start a new generation
     * Returns null if a generation is already in progress for this conversation
     * Automatically cleans up stale generations (older than 5 minutes)
     */ startGeneration(conversationId, generationId) {
        return __awaiter(this, void 0, void 0, function*() {
            const genId = generationId || this.generateGenerationId();
            // Check if a generation is already in progress
            const stateKey = types_1.RedisKeys.conversationGeneration(conversationId);
            const stateJson = yield this.redis.get(stateKey);
            if (stateJson) {
                const state = JSON.parse(stateJson);
                if (state.currentGenerationId) {
                    // Check if it's still actually generating
                    const genKey = types_1.RedisKeys.generation(state.currentGenerationId);
                    const genJson = yield this.redis.get(genKey);
                    if (genJson) {
                        const gen = JSON.parse(genJson);
                        if (gen.status === 'generating') {
                            // Check if generation is stale (older than 5 minutes)
                            const ageMs = Date.now() - gen.startedAt;
                            const maxAgeMs = 5 * 60 * 1000; // 5 minutes
                            if (ageMs > maxAgeMs) {
                                console.log(`[Logger] Cleaning up stale generation: ${state.currentGenerationId} (age: ${Math.round(ageMs / 1000)}s)`);
                                // Mark as error and allow new generation
                                yield this.failGeneration(state.currentGenerationId, 'Generation timed out (stale)');
                            } else {
                                console.log(`[Logger] Generation already in progress: ${state.currentGenerationId} (age: ${Math.round(ageMs / 1000)}s)`);
                                return null; // Reject concurrent generation
                            }
                        }
                    } else {
                        // Generation record not found, clean up state
                        console.log(`[Logger] Cleaning up orphaned generation state: ${state.currentGenerationId}`);
                        state.currentGenerationId = undefined;
                        yield this.redis.setex(stateKey, types_1.TTL.GENERATION, JSON.stringify(state));
                    }
                }
            }
            // Create generation record
            const generation = {
                id: genId,
                conversationId,
                status: 'generating',
                startedAt: Date.now()
            };
            yield this.redis.setex(types_1.RedisKeys.generation(genId), types_1.TTL.GENERATION, JSON.stringify(generation));
            // Update conversation generation state
            const newState = {
                conversationId,
                currentGenerationId: genId,
                lastGenerationId: genId,
                generationCount: stateJson ? JSON.parse(stateJson).generationCount + 1 : 1
            };
            yield this.redis.setex(stateKey, types_1.TTL.GENERATION, JSON.stringify(newState));
            // Log generation start
            yield this.log({
                level: 'info',
                category: 'generation',
                message: `<cyan>Generation started</cyan>`,
                generationId: genId,
                conversationId
            });
            return genId;
        });
    }
    /**
     * Complete a generation
     */ completeGeneration(generationId, data) {
        return __awaiter(this, void 0, void 0, function*() {
            const genKey = types_1.RedisKeys.generation(generationId);
            const genJson = yield this.redis.get(genKey);
            if (!genJson) {
                console.warn(`[Logger] Generation not found: ${generationId}`);
                return;
            }
            const generation = JSON.parse(genJson);
            generation.status = 'completed';
            generation.completedAt = Date.now();
            generation.response = data.response;
            generation.thinking = data.thinking;
            generation.route = data.route;
            generation.toolsUsed = data.toolsUsed;
            generation.model = data.model;
            generation.tokens = data.tokens;
            yield this.redis.setex(genKey, types_1.TTL.GENERATION, JSON.stringify(generation));
            // Clear current generation from conversation state
            const stateKey = types_1.RedisKeys.conversationGeneration(generation.conversationId);
            const stateJson = yield this.redis.get(stateKey);
            if (stateJson) {
                const state = JSON.parse(stateJson);
                if (state.currentGenerationId === generationId) {
                    state.currentGenerationId = undefined;
                    yield this.redis.setex(stateKey, types_1.TTL.GENERATION, JSON.stringify(state));
                }
            }
            // Log completion
            const duration = generation.completedAt - generation.startedAt;
            yield this.log({
                level: 'success',
                category: 'generation',
                message: `<green>Generation completed</green> <dim>(${duration}ms)</dim>`,
                generationId,
                conversationId: generation.conversationId,
                metadata: {
                    duration,
                    tokens: data.tokens,
                    route: data.route,
                    toolsUsed: data.toolsUsed
                }
            });
            // Also persist the assistant response as a chat log so UI and DB have the actual text
            if (data.response && typeof data.response === 'string') {
                const maxLen = 10000; // safety cutoff to avoid extremely large single logs
                const truncated = data.response.length > maxLen;
                const respText = truncated ? data.response.slice(0, maxLen) : data.response;
                yield this.log({
                    level: 'info',
                    category: 'chat',
                    message: respText,
                    generationId,
                    conversationId: generation.conversationId,
                    metadata: {
                        contentLength: data.response.length,
                        truncated,
                        model: data.model
                    }
                });
            }
        });
    }
    /**
     * Fail a generation
     */ failGeneration(generationId, error) {
        return __awaiter(this, void 0, void 0, function*() {
            const genKey = types_1.RedisKeys.generation(generationId);
            const genJson = yield this.redis.get(genKey);
            if (!genJson) {
                console.warn(`[Logger] Generation not found: ${generationId}`);
                return;
            }
            const generation = JSON.parse(genJson);
            generation.status = 'error';
            generation.completedAt = Date.now();
            generation.error = error;
            yield this.redis.setex(genKey, types_1.TTL.GENERATION, JSON.stringify(generation));
            // Clear current generation from conversation state
            const stateKey = types_1.RedisKeys.conversationGeneration(generation.conversationId);
            const stateJson = yield this.redis.get(stateKey);
            if (stateJson) {
                const state = JSON.parse(stateJson);
                if (state.currentGenerationId === generationId) {
                    state.currentGenerationId = undefined;
                    yield this.redis.setex(stateKey, types_1.TTL.GENERATION, JSON.stringify(state));
                }
            }
            // Log error
            yield this.log({
                level: 'error',
                category: 'generation',
                message: `<red>Generation failed:</red> ${error}`,
                generationId,
                conversationId: generation.conversationId,
                metadata: {
                    error
                }
            });
        });
    }
    /**
     * Log a message
     */ log(params) {
        return __awaiter(this, void 0, void 0, function*() {
            const logEntry = {
                id: this.generateLogId(),
                timestamp: Date.now(),
                level: params.level,
                category: params.category,
                message: params.message,
                generationId: params.generationId,
                conversationId: params.conversationId,
                metadata: params.metadata
            };
            // Store individual log
            yield this.redis.setex(types_1.RedisKeys.log(logEntry.id), types_1.TTL.LOG, JSON.stringify(logEntry));
            // Add to generation logs list
            if (params.generationId) {
                const listKey = types_1.RedisKeys.generationLogs(params.generationId);
                yield this.redis.rpush(listKey, logEntry.id);
                yield this.redis.expire(listKey, types_1.TTL.LOG_LIST);
            }
            // Add to conversation logs list
            if (params.conversationId) {
                const listKey = types_1.RedisKeys.conversationLogs(params.conversationId);
                yield this.redis.rpush(listKey, logEntry.id);
                yield this.redis.expire(listKey, types_1.TTL.LOG_LIST);
            }
            // Publish to pub/sub channels
            const logJson = JSON.stringify(logEntry);
            // Publish to generation channel
            if (params.generationId) {
                yield this.redis.publish(types_1.RedisKeys.logChannel(params.generationId), logJson);
            }
            // Publish to conversation channel
            if (params.conversationId) {
                yield this.redis.publish(types_1.RedisKeys.conversationLogChannel(params.conversationId), logJson);
            }
            // Publish to all logs channel
            yield this.redis.publish(types_1.RedisKeys.allLogsChannel, logJson);
        });
    }
    /**
     * Log thinking/reasoning separately from responses
     */ logThought(params) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.log({
                level: 'debug',
                category: 'thought',
                message: `<dim>💭 ${params.source} thinking:</dim>\n${params.content}`,
                generationId: params.generationId,
                conversationId: params.conversationId,
                metadata: Object.assign({
                    source: params.source
                }, params.metadata)
            });
        });
    }
    /**
     * Get all logs for a generation
     */ getGenerationLogs(generationId) {
        return __awaiter(this, void 0, void 0, function*() {
            const listKey = types_1.RedisKeys.generationLogs(generationId);
            const logIds = yield this.redis.lrange(listKey, 0, -1);
            const logs = [];
            for (const logId of logIds){
                const logJson = yield this.redis.get(types_1.RedisKeys.log(logId));
                if (logJson) {
                    logs.push(JSON.parse(logJson));
                }
            }
            return logs;
        });
    }
    /**
     * Get all logs for a conversation
     */ getConversationLogs(conversationId, limit) {
        return __awaiter(this, void 0, void 0, function*() {
            const listKey = types_1.RedisKeys.conversationLogs(conversationId);
            const logIds = yield this.redis.lrange(listKey, limit ? -limit : 0, -1);
            const logs = [];
            for (const logId of logIds){
                const logJson = yield this.redis.get(types_1.RedisKeys.log(logId));
                if (logJson) {
                    logs.push(JSON.parse(logJson));
                }
            }
            return logs;
        });
    }
    /**
     * Get generation data
     */ getGeneration(generationId) {
        return __awaiter(this, void 0, void 0, function*() {
            const genJson = yield this.redis.get(types_1.RedisKeys.generation(generationId));
            return genJson ? JSON.parse(genJson) : null;
        });
    }
    /**
     * Get conversation generation state
     */ getConversationGenerationState(conversationId) {
        return __awaiter(this, void 0, void 0, function*() {
            const stateJson = yield this.redis.get(types_1.RedisKeys.conversationGeneration(conversationId));
            return stateJson ? JSON.parse(stateJson) : null;
        });
    }
    /**
     * Subscribe to logs for a generation (real-time streaming)
     */ subscribeToGeneration(generationId) {
        return __asyncGenerator(this, arguments, function* subscribeToGeneration_1() {
            const subscriber = this.redis.duplicate();
            subscriber.setMaxListeners(100);
            const channel = types_1.RedisKeys.logChannel(generationId);
            try {
                yield __await(subscriber.subscribe(channel));
                // Yield existing logs first
                const existingLogs = yield __await(this.getGenerationLogs(generationId));
                for (const log of existingLogs){
                    yield yield __await(log);
                }
                // Then stream new logs
                while(true){
                    const message = yield __await(new Promise((resolve)=>{
                        subscriber.once('message', (ch, msg)=>{
                            if (ch === channel) resolve(msg);
                        });
                        // Timeout after 30 seconds
                        setTimeout(()=>resolve(null), 30000);
                    }));
                    if (message === null) {
                        // Check if generation is complete
                        const gen = yield __await(this.getGeneration(generationId));
                        if (!gen || gen.status !== 'generating') {
                            break;
                        }
                        continue;
                    }
                    const logEntry = JSON.parse(message);
                    yield yield __await(logEntry);
                    // Break if generation complete/error log
                    if (logEntry.category === 'generation' && (logEntry.message.includes('completed') || logEntry.message.includes('failed'))) {
                        break;
                    }
                }
            } finally{
                yield __await(subscriber.unsubscribe(channel));
                yield __await(subscriber.quit());
            }
        });
    }
    /**
     * Subscribe to all logs for a conversation (real-time streaming)
     */ subscribeToConversation(conversationId) {
        return __asyncGenerator(this, arguments, function* subscribeToConversation_1() {
            const subscriber = this.redis.duplicate();
            subscriber.setMaxListeners(100);
            const channel = types_1.RedisKeys.conversationLogChannel(conversationId);
            try {
                yield __await(subscriber.subscribe(channel));
                while(true){
                    const message = yield __await(new Promise((resolve)=>{
                        subscriber.once('message', (ch, msg)=>{
                            if (ch === channel) resolve(msg);
                        });
                        // Timeout after 60 seconds
                        setTimeout(()=>resolve(null), 60000);
                    }));
                    if (message === null) {
                        continue; // Keep alive
                    }
                    const logEntry = JSON.parse(message);
                    yield yield __await(logEntry);
                }
            } finally{
                yield __await(subscriber.unsubscribe(channel));
                yield __await(subscriber.quit());
            }
        });
    }
}
exports.Logger = Logger;
}),
"[project]/node_modules/@redbtn/ai/dist/lib/models.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// /lib/models.ts
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createLocalModel = createLocalModel;
exports.createOpenAIModel = createOpenAIModel;
exports.createGeminiModel = createGeminiModel;
const ollama_1 = __turbopack_context__.r("[project]/node_modules/@langchain/ollama/index.cjs [app-route] (ecmascript)");
const openai_1 = __turbopack_context__.r("[project]/node_modules/@langchain/openai/index.cjs [app-route] (ecmascript)");
const google_genai_1 = __turbopack_context__.r("[project]/node_modules/@langchain/google-genai/index.cjs [app-route] (ecmascript)");
/**
 * Creates a fast chat model instance based on the provided configuration.
 * Supports DeepSeek-R1 and other Ollama models.
 * @param config The Red configuration object.
 * @returns A configured instance of ChatOllama.
 */ function createLocalModel(config) {
    // Allow model override via environment variable
    const modelName = process.env.OLLAMA_MODEL || "Red";
    return new ollama_1.ChatOllama({
        baseUrl: config.defaultLlmUrl || process.env.OLLAMA_BASE_URL || "http://localhost:11434",
        model: modelName,
        temperature: 0.0
    });
}
function createOpenAIModel() {
    return new openai_1.ChatOpenAI({
        modelName: "gpt-5",
        temperature: 0.0,
        streaming: true,
        openAIApiKey: process.env.OPENAI_API_KEY
    });
}
/**
 * Creates a Gemini chat model instance.
 * @returns A configured instance of ChatGoogleGenerativeAI.
 */ function createGeminiModel() {
    return new google_genai_1.ChatGoogleGenerativeAI({
        model: "gemini-2.5-pro",
        temperature: 0.0,
        streaming: true,
        apiKey: process.env.GOOGLE_API_KEY
    });
}
}),
"[project]/node_modules/@redbtn/ai/dist/functions/background/summarization.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Background summarization utilities
 */ var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.summarizeInBackground = summarizeInBackground;
exports.generateExecutiveSummaryInBackground = generateExecutiveSummaryInBackground;
/**
 * Trigger summarization in background (non-blocking)
 */ function summarizeInBackground(conversationId, memory, localModel) {
    memory.summarizeIfNeeded(conversationId, (prompt)=>__awaiter(this, void 0, void 0, function*() {
            const response = yield localModel.invoke([
                {
                    role: 'user',
                    content: prompt
                }
            ]);
            return response.content;
        })).catch((err)=>console.error('[Red] Summarization failed:', err));
}
/**
 * Generate executive summary in background (non-blocking)
 * Called after 3rd+ AI response
 */ function generateExecutiveSummaryInBackground(conversationId, memory, localModel) {
    memory.generateExecutiveSummary(conversationId, (prompt)=>__awaiter(this, void 0, void 0, function*() {
            const response = yield localModel.invoke([
                {
                    role: 'user',
                    content: prompt
                }
            ]);
            return response.content;
        })).catch((err)=>console.error('[Red] Executive summary generation failed:', err));
}
}),
"[project]/node_modules/@redbtn/ai/dist/functions/background/title.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Background title generation utilities
 */ var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.generateTitleInBackground = generateTitleInBackground;
exports.setConversationTitle = setConversationTitle;
exports.getConversationTitle = getConversationTitle;
/**
 * Generate a title for the conversation based on the first few messages
 * Runs after 2nd message (initial title) and 6th message (refined title)
 */ function generateTitleInBackground(conversationId, messageCount, memory, localModel) {
    return __awaiter(this, void 0, void 0, function*() {
        try {
            // Only generate title after 2nd or 6th message
            if (messageCount !== 2 && messageCount !== 6) {
                return;
            }
            // Check if title was manually set by user
            const metadata = yield memory.getMetadata(conversationId);
            if (metadata === null || metadata === void 0 ? void 0 : metadata.titleSetByUser) {
                return; // Don't override user-set titles after 6th message
            }
            // Get recent messages for context
            const messages = yield memory.getMessages(conversationId);
            const conversationText = messages.slice(0, Math.min(6, messages.length)) // Use first 6 messages max
            .map((m)=>`${m.role.toUpperCase()}: ${m.content}`).join('\n');
            // Create prompt for title generation
            const titlePrompt = `Based on this conversation, generate a short, descriptive title (3-6 words max). Only respond with the title, nothing else:

${conversationText}`;
            // Generate title using LLM
            const response = yield localModel.invoke([
                {
                    role: 'user',
                    content: titlePrompt
                }
            ]);
            const title = response.content.trim().replace(/^["']|["']$/g, ''); // Remove quotes if any
            // Store title in metadata
            const metaKey = `conversation:${conversationId}:metadata`;
            yield memory['redis'].hset(metaKey, 'title', title);
            console.log(`[Red] Generated title for ${conversationId}: "${title}"`);
        } catch (err) {
            console.error('[Red] Title generation failed:', err);
        }
    });
}
/**
 * Set a custom title for a conversation (set by user)
 * This prevents automatic title generation from overwriting it
 */ function setConversationTitle(conversationId, title, memory) {
    return __awaiter(this, void 0, void 0, function*() {
        const metaKey = `conversation:${conversationId}:metadata`;
        yield memory['redis'].hset(metaKey, {
            'title': title,
            'titleSetByUser': 'true'
        });
        console.log(`[Red] User set title for ${conversationId}: "${title}"`);
    });
}
/**
 * Get the title for a conversation
 */ function getConversationTitle(conversationId, memory) {
    return __awaiter(this, void 0, void 0, function*() {
        const metadata = yield memory.getMetadata(conversationId);
        return (metadata === null || metadata === void 0 ? void 0 : metadata.title) || null;
    });
}
}),
"[project]/node_modules/@redbtn/ai/dist/functions/background/heartbeat.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Node heartbeat utilities for distributed system monitoring
 */ var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.startHeartbeat = startHeartbeat;
exports.sendHeartbeat = sendHeartbeat;
exports.stopHeartbeat = stopHeartbeat;
exports.getActiveNodes = getActiveNodes;
/**
 * Starts the heartbeat mechanism to register this node as active in Redis.
 * Heartbeat runs every 10 seconds with a 20-second TTL.
 */ function startHeartbeat(nodeId, redis) {
    if (!nodeId) {
        console.warn('[Heartbeat] No nodeId set, skipping heartbeat');
        throw new Error('nodeId is required for heartbeat');
    }
    // Initial heartbeat
    sendHeartbeat(nodeId, redis);
    // Set up interval for continuous heartbeats
    const interval = setInterval(()=>{
        sendHeartbeat(nodeId, redis);
    }, 10000); // Every 10 seconds
    console.log(`[Heartbeat] Started for node: ${nodeId}`);
    return interval;
}
/**
 * Sends a heartbeat signal to Redis, adding the node to the active set.
 */ function sendHeartbeat(nodeId, redis) {
    return __awaiter(this, void 0, void 0, function*() {
        if (!nodeId) return;
        try {
            const key = `nodes:active:${nodeId}`;
            const timestamp = Date.now();
            // Set key with value as timestamp and 20-second TTL
            yield redis.setex(key, 20, timestamp.toString());
        } catch (error) {
            console.error('[Heartbeat] Failed to send heartbeat:', error);
        }
    });
}
/**
 * Stops the heartbeat mechanism and removes the node from active set.
 */ function stopHeartbeat(nodeId, redis, interval) {
    return __awaiter(this, void 0, void 0, function*() {
        if (interval) {
            clearInterval(interval);
        }
        if (nodeId) {
            try {
                // Remove node from active set
                const key = `nodes:active:${nodeId}`;
                yield redis.del(key);
                console.log(`[Heartbeat] Stopped for node: ${nodeId}`);
            } catch (error) {
                console.error('[Heartbeat] Failed to cleanup on stop:', error);
            }
        }
    });
}
/**
 * Gets a list of all currently active nodes.
 * @returns Array of active node IDs
 */ function getActiveNodes(redis) {
    return __awaiter(this, void 0, void 0, function*() {
        try {
            // Scan for all keys matching nodes:active:*
            const keys = yield redis.keys('nodes:active:*');
            // Extract nodeId from keys (nodes:active:nodeId)
            return keys.map((key)=>key.replace('nodes:active:', ''));
        } catch (error) {
            console.error('[Heartbeat] Failed to get active nodes:', error);
            return [];
        }
    });
}
}),
"[project]/node_modules/@redbtn/ai/dist/functions/background/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Background process utilities
 * Re-exports all background processing functions
 */ var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/functions/background/summarization.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/functions/background/title.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/functions/background/heartbeat.js [app-route] (ecmascript)"), exports);
}),
"[project]/node_modules/@redbtn/ai/dist/lib/utils/thinking.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Utility functions for extracting and logging reasoning/thinking from LLM responses
 * Works with any model - thinking models (DeepSeek-R1) and non-thinking models (qwen, GPT)
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.extractThinking = extractThinking;
exports.logThinking = logThinking;
exports.extractAndLogThinking = extractAndLogThinking;
/**
 * Extracts thinking content from DeepSeek-R1 style <think>...</think> tags
 * Safe for all models - returns original content if no thinking tags found
 * @param content The full content from the LLM response
 * @returns Object with thinking (if any) and cleaned content
 */ function extractThinking(content) {
    if (!content || typeof content !== 'string') {
        return {
            thinking: null,
            cleanedContent: content || ''
        };
    }
    // Match <think>...</think> tags (case insensitive, multiline)
    const thinkRegex = /<think>([\s\S]*?)<\/think>/gi;
    const matches = [
        ...content.matchAll(thinkRegex)
    ];
    if (matches.length === 0) {
        // No thinking tags - return content as-is
        return {
            thinking: null,
            cleanedContent: content
        };
    }
    // Extract all thinking sections
    const thinkingSections = matches.map((m)=>m[1].trim());
    const thinking = thinkingSections.join('\n\n---\n\n');
    // Remove thinking tags from content and clean up whitespace
    let cleanedContent = content.replace(thinkRegex, '');
    // Remove leading/trailing whitespace and collapse multiple newlines
    cleanedContent = cleanedContent.trim().replace(/\n{3,}/g, '\n\n'); // Max 2 consecutive newlines
    return {
        thinking,
        cleanedContent
    };
}
/**
 * Logs thinking to console with nice formatting
 * Only logs if thinking content exists - safe to call with null
 * @param thinking The thinking/reasoning text to log (can be null)
 * @param context Optional context label (e.g., "Router", "Chat", "ToolPicker")
 */ function logThinking(thinking, context = 'LLM') {
    // Don't log if no thinking content
    if (!thinking || thinking.trim().length === 0) {
        return;
    }
    const boxWidth = 80;
    const borderTop = '╔' + '═'.repeat(boxWidth - 2) + '╗';
    const borderBottom = '╚' + '═'.repeat(boxWidth - 2) + '╝';
    const header = `💭 ${context} Thinking`;
    console.log('\n' + borderTop);
    console.log('║ ' + header.padEnd(boxWidth - 3) + '║');
    console.log('╠' + '═'.repeat(boxWidth - 2) + '╣');
    // Split thinking into lines and wrap to fit in box
    const lines = thinking.split('\n');
    lines.forEach((line)=>{
        if (line.length === 0) {
            console.log('║' + ' '.repeat(boxWidth - 2) + '║');
            return;
        }
        // Word wrap long lines
        const words = line.split(' ');
        let currentLine = '';
        words.forEach((word)=>{
            if ((currentLine + ' ' + word).length > boxWidth - 6) {
                // Print current line and start new one
                console.log('║ ' + currentLine.padEnd(boxWidth - 3) + '║');
                currentLine = word;
            } else {
                currentLine = currentLine ? currentLine + ' ' + word : word;
            }
        });
        // Print remaining text
        if (currentLine) {
            console.log('║ ' + currentLine.padEnd(boxWidth - 3) + '║');
        }
    });
    console.log(borderBottom + '\n');
}
/**
 * Extracts and logs thinking from content in one call
 * Returns the cleaned content
 * @param content The full content from the LLM response
 * @param context Optional context label
 * @returns The cleaned content (without thinking tags)
 */ function extractAndLogThinking(content, context = 'LLM') {
    const { thinking, cleanedContent } = extractThinking(content);
    if (thinking) {
        logThinking(thinking, context);
    }
    return cleanedContent;
}
}),
"[project]/node_modules/@redbtn/ai/dist/lib/nodes/router.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.routerNode = void 0;
const thinking_1 = __turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/lib/utils/thinking.js [app-route] (ecmascript)");
/**
 * The first node in redGraph, acting as an intelligent router.
 * Analyzes the user query with conversation context to determine the next action:
 * - web_search: Query needs current information from the internet
 * - scrape_url: User provided a specific URL to scrape
 * - system_command: User wants to execute a system command
 * - chat: Query can be answered directly without external tools
 *
 * @param state The current state of the graph.
 * @returns A partial state object indicating the next step.
 */ const routerNode = (state)=>__awaiter(void 0, void 0, void 0, function*() {
        var _a, _b, _c, _d;
        const query = ((_a = state.messages[state.messages.length - 1]) === null || _a === void 0 ? void 0 : _a.content) || ((_b = state.query) === null || _b === void 0 ? void 0 : _b.message) || '';
        const redInstance = state.redInstance;
        const conversationId = (_c = state.options) === null || _c === void 0 ? void 0 : _c.conversationId;
        const generationId = (_d = state.options) === null || _d === void 0 ? void 0 : _d.generationId;
        // Log router start
        yield redInstance.logger.log({
            level: 'info',
            category: 'router',
            message: `<cyan>🧭 Analyzing query:</cyan> <dim>${query.substring(0, 80)}${query.length > 80 ? '...' : ''}</dim>`,
            generationId,
            conversationId
        });
        // Get executive summary for context (if exists)
        let contextSummary = '';
        if (conversationId) {
            const summary = yield redInstance.memory.getExecutiveSummary(conversationId);
            if (summary) {
                contextSummary = `\n\nConversation Context: ${summary}`;
            }
        }
        try {
            const currentDate = new Date().toLocaleDateString('en-US', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
            const routingDecision = yield redInstance.localModel.invoke([
                {
                    role: 'system',
                    content: `You are a routing cognition node for an Artificial Intelligence named Red.

          TODAY'S DATE: ${currentDate}

          ${contextSummary ? `CONVERSATION SUMMARY: ${contextSummary}` : ''}`
                },
                {
                    role: 'user',
                    content: `Analyze the user's message and classify it into ONE category.

Categories:
- WEB_SEARCH = needs current/recent information from the internet
- SCRAPE_URL = user provided a specific URL to read
- SYSTEM_COMMAND = user wants to execute a system command  
- CHAT = everything else (greetings, questions, general knowledge)

Your response MUST be EXACTLY one of these formats:
- WEB_SEARCH
- SCRAPE_URL: [url]
- SYSTEM_COMMAND: [command]
- CHAT

Use <think> tags for your reasoning, then give ONLY the category name outside the tags.

User message: ${query}`
                }
            ]);
            let rawContent = routingDecision.content.toString().trim();
            // Extract thinking if present (safe for all models - returns original if no thinking)
            const { thinking, cleanedContent } = (0, thinking_1.extractThinking)(rawContent);
            // Log thinking to console (for development)
            (0, thinking_1.logThinking)(thinking, 'Router');
            // Log thinking to logging system (separate from response)
            if (thinking && generationId && conversationId) {
                yield redInstance.logger.logThought({
                    content: thinking,
                    source: 'router',
                    generationId,
                    conversationId
                });
            }
            // Extract just the routing action from the response
            // Look for WEB_SEARCH, CHAT, SCRAPE_URL, or SYSTEM_COMMAND
            // Prioritize patterns with URL/command, then standalone keywords
            // Also handle variations like "Web Search:" or "web_search"
            const routingPatterns = [
                {
                    pattern: /\b(SCRAPE_URL:\s*https?:\/\/[^\s<]+)/i,
                    name: 'SCRAPE_URL_WITH_URL'
                },
                {
                    pattern: /\b(SYSTEM_COMMAND:\s*[^\n<]+)/i,
                    name: 'SYSTEM_COMMAND_WITH_CMD'
                },
                {
                    pattern: /^(WEB[_\s-]?SEARCH)\b/im,
                    name: 'WEB_SEARCH_LINE_START'
                },
                {
                    pattern: /\b(WEB[_\s-]?SEARCH)\b/i,
                    name: 'WEB_SEARCH'
                },
                {
                    pattern: /^(SCRAPE[_\s-]?URL)\b/im,
                    name: 'SCRAPE_URL_LINE_START'
                },
                {
                    pattern: /\b(SCRAPE[_\s-]?URL)\b/i,
                    name: 'SCRAPE_URL'
                },
                {
                    pattern: /^(SYSTEM[_\s-]?COMMAND)\b/im,
                    name: 'SYSTEM_COMMAND_LINE_START'
                },
                {
                    pattern: /\b(SYSTEM[_\s-]?COMMAND)\b/i,
                    name: 'SYSTEM_COMMAND'
                },
                {
                    pattern: /^(CHAT)\b/im,
                    name: 'CHAT_LINE_START'
                },
                {
                    pattern: /\b(CHAT)\b/i,
                    name: 'CHAT'
                }
            ];
            let decision = '';
            // First try to find pattern in cleaned content (outside thinking tags)
            for (const { pattern, name } of routingPatterns){
                const match = cleanedContent.match(pattern);
                if (match) {
                    // Normalize to standard format (WEB_SEARCH, not WEB SEARCH)
                    decision = match[1].toUpperCase().replace(/[\s-]/g, '_').trim();
                    break;
                }
            }
            // If not found in cleaned content, look in thinking
            if (!decision && thinking) {
                for (const { pattern, name } of routingPatterns){
                    const match = thinking.match(pattern);
                    if (match) {
                        // Normalize to standard format (WEB_SEARCH, not WEB SEARCH)
                        decision = match[1].toUpperCase().replace(/[\s-]/g, '_').trim();
                        break;
                    }
                }
            }
            // Single log showing final routing decision with cleaned answer
            console.log(`[Router] Decision: ${decision || 'CHAT'} (from ${cleanedContent.substring(0, 50)}${cleanedContent.length > 50 ? '...' : ''})`);
            if (decision.startsWith('WEB_SEARCH')) {
                yield redInstance.logger.log({
                    level: 'success',
                    category: 'router',
                    message: `<green>→ Route:</green> <bold>WEB_SEARCH</bold>`,
                    generationId,
                    conversationId,
                    metadata: {
                        decision: 'WEB_SEARCH',
                        nextGraph: 'toolPicker',
                        toolAction: 'web_search'
                    }
                });
                return {
                    nextGraph: 'toolPicker',
                    toolAction: 'web_search'
                };
            }
            if (decision.startsWith('SCRAPE_URL')) {
                const urlMatch = decision.match(/SCRAPE_URL:\s*(.+)$/i);
                const url = urlMatch ? urlMatch[1].trim() : '';
                yield redInstance.logger.log({
                    level: 'success',
                    category: 'router',
                    message: `<green>→ Route:</green> <bold>SCRAPE_URL</bold> <dim>${url}</dim>`,
                    generationId,
                    conversationId,
                    metadata: {
                        decision: 'SCRAPE_URL',
                        url,
                        nextGraph: 'toolPicker',
                        toolAction: 'scrape_url'
                    }
                });
                return {
                    nextGraph: 'toolPicker',
                    toolAction: 'scrape_url',
                    toolParam: url
                };
            }
            if (decision.startsWith('SYSTEM_COMMAND')) {
                const cmdMatch = decision.match(/SYSTEM_COMMAND:\s*(.+)$/i);
                const command = cmdMatch ? cmdMatch[1].trim() : '';
                yield redInstance.logger.log({
                    level: 'success',
                    category: 'router',
                    message: `<green>→ Route:</green> <bold>SYSTEM_COMMAND</bold> <dim>${command}</dim>`,
                    generationId,
                    conversationId,
                    metadata: {
                        decision: 'SYSTEM_COMMAND',
                        command,
                        nextGraph: 'toolPicker',
                        toolAction: 'system_command'
                    }
                });
                return {
                    nextGraph: 'toolPicker',
                    toolAction: 'system_command',
                    toolParam: command
                };
            }
            // Default to CHAT
            yield redInstance.logger.log({
                level: 'success',
                category: 'router',
                message: `<green>→ Route:</green> <bold>CHAT</bold>`,
                generationId,
                conversationId,
                metadata: {
                    decision: 'CHAT',
                    nextGraph: 'chat'
                }
            });
            return {
                nextGraph: 'chat'
            };
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            yield redInstance.logger.log({
                level: 'error',
                category: 'router',
                message: `<red>✗ Router error:</red> ${errorMessage} <dim>(defaulting to CHAT)</dim>`,
                generationId,
                conversationId,
                metadata: {
                    error: errorMessage
                }
            });
            return {
                nextGraph: 'chat'
            };
        }
    });
exports.routerNode = routerNode;
}),
"[project]/node_modules/@redbtn/ai/dist/lib/nodes/chat.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__asyncValues || function(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
    //TURBOPACK unreachable
    ;
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.chatNode = void 0;
const messages_1 = __turbopack_context__.r("[project]/node_modules/@langchain/core/messages.cjs [app-route] (ecmascript)");
/**
 * The chat node that processes queries and generates responses.
 * Tools are bound to the model, and tool execution is handled by the toolNode.
 * @param state The current state of the graph.
 * @returns A partial state object with the response and updated messages.
 */ const chatNode = (state)=>__awaiter(void 0, void 0, void 0, function*() {
        var _a, e_1, _b, _c;
        var _d, _e;
        try {
            const redInstance = state.redInstance;
            const query = state.query;
            const options = state.options || {};
            const conversationId = options.conversationId;
            const generationId = options.generationId;
            // Log chat node start
            yield redInstance.logger.log({
                level: 'info',
                category: 'chat',
                message: `<cyan>💬 Generating response...</cyan>`,
                generationId,
                conversationId
            });
            // Never bind tools in chat node - tools are only executed by toolPicker
            // This prevents infinite loops where the LLM keeps calling tools
            const modelWithTools = redInstance.localModel;
            // Build messages array - start with existing messages from state
            let messages = [
                ...state.messages || []
            ];
            console.log('[Chat] Initial messages from state:', messages.length);
            // Check if the user query is already in messages
            const userQueryAlreadyAdded = messages.some((m)=>{
                var _a;
                return (m.role === 'user' || ((_a = m._getType) === null || _a === void 0 ? void 0 : _a.call(m)) === 'human') && m.content === query.message;
            });
            console.log('[Chat] User query already in messages?', userQueryAlreadyAdded);
            if (!userQueryAlreadyAdded) {
                const initialMessages = [];
                // Inject system message if provided by the caller (respond())
                if (state.systemMessage) {
                    initialMessages.push({
                        role: 'system',
                        content: state.systemMessage
                    });
                }
                if (conversationId) {
                    // Get summary (if exists) and recent messages separately
                    const summary = yield redInstance.memory.getContextSummary(conversationId);
                    const recentMessages = yield redInstance.memory.getContextForConversation(conversationId);
                    console.log('[Chat] Loaded from memory - Summary:', !!summary, 'Recent messages:', recentMessages.length);
                    console.log('[Chat] Recent messages:', recentMessages.map((m)=>{
                        var _a;
                        return {
                            role: m.role,
                            content: (_a = m.content) === null || _a === void 0 ? void 0 : _a.substring(0, 30)
                        };
                    }));
                    // Since Ollama doesn't combine system messages, we append summary
                    // as a contextual user message instead (less intrusive than overriding system prompt)
                    if (summary) {
                        initialMessages.push({
                            role: 'user',
                            content: `[Previous conversation context: ${summary}]`
                        });
                    }
                    // Add recent conversation messages (user/assistant pairs)
                    // Filter out the CURRENT user message (it will be added separately)
                    const filteredMessages = recentMessages.filter((msg)=>!(msg.role === 'user' && msg.content === query.message));
                    console.log('[Chat] Filtered out current message, remaining:', filteredMessages.length);
                    initialMessages.push(...filteredMessages.map((msg)=>({
                            role: msg.role,
                            content: msg.content
                        })));
                }
                // Prepend initial context, then add existing messages (e.g., tool results), then user query
                messages = [
                    ...initialMessages,
                    ...messages
                ];
                // Add the current user query
                if (query && query.message) {
                    messages.push({
                        role: 'user',
                        content: query.message
                    });
                }
            }
            console.log('[Chat] Final message count before LLM:', messages.length);
            console.log('[Chat] Last 3 messages:', messages.slice(-3).map((m)=>{
                var _a;
                return {
                    role: m.role,
                    content: (_a = m.content) === null || _a === void 0 ? void 0 : _a.substring(0, 50)
                };
            }));
            // Use streaming to get real-time chunks (including thinking tags)
            const stream = yield modelWithTools.stream(messages);
            let fullContent = '';
            let usage_metadata = null;
            let response_metadata = null;
            try {
                // Accumulate chunks into full content
                for(var _f = true, stream_1 = __asyncValues(stream), stream_1_1; stream_1_1 = yield stream_1.next(), _a = stream_1_1.done, !_a; _f = true){
                    _c = stream_1_1.value;
                    _f = false;
                    const chunk = _c;
                    if (chunk.content) {
                        fullContent += chunk.content;
                    }
                    if (chunk.usage_metadata) {
                        usage_metadata = chunk.usage_metadata;
                    }
                    if (chunk.response_metadata) {
                        response_metadata = chunk.response_metadata;
                    }
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (!_f && !_a && (_b = stream_1.return)) yield _b.call(stream_1);
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
            // LOG THE FULL CONTENT TO PROVE THINKING IS THERE
            console.log('='.repeat(80));
            console.log('[Chat] FULL ACCUMULATED CONTENT FROM LLM:');
            console.log('='.repeat(80));
            console.log(fullContent);
            console.log('='.repeat(80));
            console.log(`[Chat] Total length: ${fullContent.length} chars`);
            console.log('='.repeat(80));
            // Construct AIMessage from accumulated content
            const aiMessage = new messages_1.AIMessage({
                content: fullContent,
                usage_metadata,
                response_metadata
            });
            // Log response metadata (including thinking tags if present)
            yield redInstance.logger.log({
                level: 'success',
                category: 'chat',
                message: `<green>✓ Response generated</green> <dim>(${fullContent.length} chars, ${(usage_metadata === null || usage_metadata === void 0 ? void 0 : usage_metadata.total_tokens) || 0} tokens)</dim>`,
                generationId,
                conversationId,
                metadata: {
                    contentLength: fullContent.length,
                    tokens: usage_metadata,
                    model: response_metadata === null || response_metadata === void 0 ? void 0 : response_metadata.model
                }
            });
            return {
                response: aiMessage,
                messages: [
                    aiMessage
                ] // Add AI message to state messages
            };
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            const generationId = (_d = state.options) === null || _d === void 0 ? void 0 : _d.generationId;
            const conversationId = (_e = state.options) === null || _e === void 0 ? void 0 : _e.conversationId;
            if (generationId && conversationId) {
                yield state.redInstance.logger.log({
                    level: 'error',
                    category: 'chat',
                    message: `<red>✗ Chat error:</red> ${errorMessage}`,
                    generationId,
                    conversationId,
                    metadata: {
                        error: errorMessage
                    }
                });
            }
            return {
                response: {
                    content: 'Error processing request.'
                },
                messages: []
            };
        }
    });
exports.chatNode = chatNode;
}),
"[project]/node_modules/@redbtn/ai/dist/lib/tools/search_web.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.webSearchTool = void 0;
const tools_1 = __turbopack_context__.r("[project]/node_modules/@langchain/core/tools.cjs [app-route] (ecmascript)");
const zod_1 = __turbopack_context__.r("[project]/node_modules/zod/index.cjs [app-route] (ecmascript)");
const searchSchema = zod_1.z.object({
    query: zod_1.z.string().describe("The search query to look up on Google")
});
/**
 * Web Search Tool - Searches Google using Custom Search API and scrapes each result
 * Requires GOOGLE_API_KEY and GOOGLE_SEARCH_ENGINE_ID environment variables
 */ class WebSearchTool extends tools_1.StructuredTool {
    constructor(){
        super(...arguments);
        this.name = "web_search";
        this.description = "Search the web using Google and get actual content from the pages. Use this when you need current information, facts, news, or data that you don't have in your training data. Returns up to 10 search results with titles, snippets, URLs, and relevant body content from each page.";
        this.schema = searchSchema; // Type assertion to bypass deep instantiation
    }
    _call(_a) {
        return __awaiter(this, arguments, void 0, function*({ query }) {
            const startTime = Date.now();
            try {
                const apiKey = process.env.GOOGLE_API_KEY;
                const searchEngineId = process.env.GOOGLE_SEARCH_ENGINE_ID || process.env.GOOGLE_CSE_ID;
                if (!apiKey) {
                    return "Error: GOOGLE_API_KEY environment variable is not set. Cannot perform web search.";
                }
                if (!searchEngineId) {
                    return "Error: GOOGLE_SEARCH_ENGINE_ID or GOOGLE_CSE_ID environment variable is not set. Cannot perform web search.";
                }
                console.log(`[Web Search Tool] Searching for: "${query}"`);
                const searchStartTime = Date.now();
                const url = `https://www.googleapis.com/customsearch/v1?key=${apiKey}&cx=${searchEngineId}&q=${encodeURIComponent(query)}&num=10`;
                const response = yield fetch(url);
                const searchDuration = Date.now() - searchStartTime;
                console.log(`[Web Search Tool] ⏱️  Google search took ${searchDuration}ms`);
                if (!response.ok) {
                    const errorData = yield response.text();
                    return `Error searching Google: ${response.status} ${response.statusText}. ${errorData}`;
                }
                const data = yield response.json();
                if (!data.items || data.items.length === 0) {
                    return `No results found for query: "${query}"`;
                }
                // Scrape each result URL in parallel
                console.log(`[Web Search Tool] Scraping ${data.items.length} results...`);
                const scrapeStartTime = Date.now();
                const scrapePromises = data.items.map((item)=>this.scrapeUrl(item.link, query).catch((err)=>`Error: ${err.message}`));
                const scrapedContents = yield Promise.all(scrapePromises);
                const scrapeDuration = Date.now() - scrapeStartTime;
                console.log(`[Web Search Tool] ⏱️  Scraped ${data.items.length} pages in ${scrapeDuration}ms (${Math.round(scrapeDuration / data.items.length)}ms avg)`);
                // Format results with scraped content
                const results = data.items.map((item, index)=>{
                    const content = scrapedContents[index];
                    return `${index + 1}. **${item.title}**
   Snippet: ${item.snippet}
   URL: ${item.link}
   
   Content:
   ${content}`;
                }).join('\n\n---\n\n');
                const totalDuration = Date.now() - startTime;
                console.log(`[Web Search Tool] ⏱️  Total execution time: ${totalDuration}ms`);
                return `Search results for "${query}":\n\n${results}`;
            } catch (error) {
                const totalDuration = Date.now() - startTime;
                console.error(`[Web Search Tool] Error after ${totalDuration}ms:`, error);
                return `Error performing web search: ${error instanceof Error ? error.message : String(error)}`;
            }
        });
    }
    /**
     * Scrape a URL and extract relevant text content based on query keywords
     * Extracts up to 1500 tokens of the most relevant content
     */ scrapeUrl(url, query) {
        return __awaiter(this, void 0, void 0, function*() {
            const scrapeStart = Date.now();
            try {
                const response = yield fetch(url, {
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (compatible; RedBot/1.0; +https://redbtn.io)'
                    },
                    signal: AbortSignal.timeout(8000) // 8 second timeout per page
                });
                if (!response.ok) {
                    console.log(`[Web Search Tool] ⏱️  ${url} - Failed (${Date.now() - scrapeStart}ms): HTTP ${response.status}`);
                    return `[Failed to fetch: HTTP ${response.status}]`;
                }
                const contentType = response.headers.get('content-type') || '';
                if (!contentType.includes('text/html') && !contentType.includes('text/plain')) {
                    console.log(`[Web Search Tool] ⏱️  ${url} - Skipped (${Date.now() - scrapeStart}ms): ${contentType}`);
                    return `[Non-HTML content: ${contentType}]`;
                }
                const html = yield response.text();
                const textContent = this.extractTextFromHtml(html);
                if (!textContent.trim()) {
                    console.log(`[Web Search Tool] ⏱️  ${url} - Empty (${Date.now() - scrapeStart}ms)`);
                    return '[No text content found]';
                }
                // Extract relevant sections based on query keywords
                const relevantContent = this.extractRelevantSections(textContent, query, 1500);
                const duration = Date.now() - scrapeStart;
                console.log(`[Web Search Tool] ⏱️  ${url} - Success (${duration}ms, ${relevantContent.length} chars)`);
                return relevantContent;
            } catch (error) {
                const duration = Date.now() - scrapeStart;
                if (error.name === 'AbortError' || error.name === 'TimeoutError') {
                    console.log(`[Web Search Tool] ⏱️  ${url} - Timeout (${duration}ms)`);
                    return '[Timeout]';
                }
                console.log(`[Web Search Tool] ⏱️  ${url} - Error (${duration}ms): ${error.message}`);
                return `[Error: ${error.message}]`;
            }
        });
    }
    /**
     * Extract the most relevant sections from text based on query keywords
     * Uses keyword matching to find paragraphs/sections that contain query terms
     */ extractRelevantSections(text, query, maxTokens) {
        // Extract keywords from query (remove common words)
        const stopWords = new Set([
            'a',
            'an',
            'the',
            'is',
            'are',
            'was',
            'were',
            'be',
            'been',
            'being',
            'have',
            'has',
            'had',
            'do',
            'does',
            'did',
            'will',
            'would',
            'should',
            'could',
            'may',
            'might',
            'what',
            'when',
            'where',
            'who',
            'which',
            'why',
            'how',
            'for',
            'to',
            'of',
            'in',
            'on',
            'at',
            'by',
            'with',
            'from',
            'about',
            'as',
            'into',
            'through',
            'during',
            'before',
            'after',
            'above',
            'below',
            'between',
            'under',
            'again',
            'further',
            'then',
            'once',
            'here',
            'there',
            'all',
            'any',
            'both',
            'each',
            'few',
            'more',
            'most',
            'other',
            'some',
            'such',
            'no',
            'nor',
            'not',
            'only',
            'own',
            'same',
            'so',
            'than',
            'too',
            'very',
            'can',
            'just',
            'today',
            'tonight',
            'this',
            'that'
        ]);
        const keywords = query.toLowerCase().split(/\s+/).filter((word)=>word.length > 2 && !stopWords.has(word));
        if (keywords.length === 0) {
            // No meaningful keywords, just truncate from beginning
            return this.truncateToTokens(text, maxTokens);
        }
        // Split text into sentences
        const sentences = text.match(/[^.!?]+[.!?]+/g) || [
            text
        ];
        // Score each sentence based on keyword matches
        const scoredSentences = sentences.map((sentence)=>{
            const lowerSentence = sentence.toLowerCase();
            let score = 0;
            for (const keyword of keywords){
                const regex = new RegExp(`\\b${keyword}\\w*\\b`, 'gi');
                const matches = lowerSentence.match(regex);
                if (matches) {
                    score += matches.length * 10; // Weight keyword matches heavily
                }
            }
            // Bonus for sentences with numbers (often contain useful data like dates, scores, times)
            if (/\d+/.test(sentence)) {
                score += 5;
            }
            return {
                sentence: sentence.trim(),
                score
            };
        });
        // Sort by score (highest first) and collect relevant content
        scoredSentences.sort((a, b)=>b.score - a.score);
        let collectedText = '';
        const usedSentences = new Set();
        // First pass: collect high-scoring sentences
        for (const item of scoredSentences){
            if (item.score > 0 && !usedSentences.has(item.sentence)) {
                const potentialText = collectedText + (collectedText ? ' ' : '') + item.sentence;
                const tokenCount = this.estimateTokens(potentialText);
                if (tokenCount > maxTokens) {
                    break;
                }
                collectedText = potentialText;
                usedSentences.add(item.sentence);
            }
        }
        // If we didn't collect enough content, add some context from the beginning
        if (this.estimateTokens(collectedText) < maxTokens * 0.5) {
            const beginningText = sentences.slice(0, 10).map((s)=>s.trim()).join(' ');
            const combined = beginningText + ' ... ' + collectedText;
            return this.truncateToTokens(combined, maxTokens);
        }
        return collectedText || this.truncateToTokens(text, maxTokens);
    }
    /**
     * Estimate token count (rough approximation: 1 token ≈ 4 characters)
     */ estimateTokens(text) {
        return Math.ceil(text.length / 4);
    }
    /**
     * Extract text from HTML by removing scripts, styles, and tags
     */ extractTextFromHtml(html) {
        let text = html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, ' ');
        text = text.replace(/<style\b[^<]*(?:(?!<\/style>)<[^<]*)*<\/style>/gi, ' ');
        text = text.replace(/<!--[\s\S]*?-->/g, ' ');
        text = text.replace(/<[^>]+>/g, ' ');
        text = text.replace(/&nbsp;/g, ' ');
        text = text.replace(/&amp;/g, '&');
        text = text.replace(/&lt;/g, '<');
        text = text.replace(/&gt;/g, '>');
        text = text.replace(/&quot;/g, '"');
        text = text.replace(/&#39;/g, "'");
        text = text.replace(/&mdash;/g, '—');
        text = text.replace(/&ndash;/g, '–');
        text = text.replace(/\s+/g, ' ');
        text = text.trim();
        return text;
    }
    /**
     * Truncate text to a maximum number of tokens
     */ truncateToTokens(text, maxTokens) {
        try {
            // Lazy-load tiktoken to avoid build-time issues with WASM
            const { encoding_for_model } = __turbopack_context__.r("[project]/node_modules/tiktoken/tiktoken.cjs [app-route] (ecmascript)");
            const encoding = encoding_for_model('gpt-3.5-turbo');
            const tokens = encoding.encode(text);
            if (tokens.length <= maxTokens) {
                encoding.free();
                return text;
            }
            const truncatedTokens = tokens.slice(0, maxTokens);
            const truncated = new TextDecoder().decode(encoding.decode(truncatedTokens));
            encoding.free();
            return truncated + '...';
        } catch (error) {
            // Fallback if tiktoken fails to load
            const estimatedChars = maxTokens * 4;
            if (text.length <= estimatedChars) {
                return text;
            }
            return text.substring(0, estimatedChars) + '...';
        }
    }
}
exports.webSearchTool = new WebSearchTool(); // Type assertion for export
}),
"[project]/node_modules/@redbtn/ai/dist/lib/tools/send_command.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sendCommandTool = void 0;
const tools_1 = __turbopack_context__.r("[project]/node_modules/@langchain/core/tools.cjs [app-route] (ecmascript)");
const zod_1 = __turbopack_context__.r("[project]/node_modules/zod/index.cjs [app-route] (ecmascript)");
const child_process_1 = __turbopack_context__.r("[externals]/child_process [external] (child_process, cjs)");
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const execAsync = (0, util_1.promisify)(child_process_1.exec);
const commandSchema = zod_1.z.object({
    command: zod_1.z.string().describe("The CLI command to execute (e.g., 'ls -la', 'pwd', 'echo hello')"),
    timeout: zod_1.z.number().optional().describe("Optional timeout in milliseconds (default: 30000)")
});
/**
 * Send Command Tool - Executes CLI commands on the system
 * SECURITY WARNING: This tool can execute arbitrary commands. Use with caution and
 * implement proper security measures in production environments.
 */ class SendCommandTool extends tools_1.StructuredTool {
    constructor(){
        super(...arguments);
        this.name = "send_command";
        this.description = "Execute a command line (CLI) command on the system. Use this to run shell commands, check system status, manage files, or interact with the operating system. Returns the command output (stdout/stderr). Use with caution as this executes real commands.";
        this.schema = commandSchema; // Type assertion to bypass deep instantiation
    }
    _call(_a) {
        return __awaiter(this, arguments, void 0, function*({ command, timeout = 30000 }) {
            const startTime = Date.now();
            try {
                // Security check: block dangerous commands
                const dangerousPatterns = [
                    /rm\s+-rf\s+\/($|\s)/,
                    /:\(\)\{.*:\|:.*\};:/,
                    /mkfs\./,
                    /dd\s+if=/
                ];
                for (const pattern of dangerousPatterns){
                    if (pattern.test(command)) {
                        return `Error: Command blocked for security reasons. This command pattern is not allowed.`;
                    }
                }
                console.log(`[Send Command Tool] Executing: ${command}`);
                const execStart = Date.now();
                const { stdout, stderr } = yield execAsync(command, {
                    timeout,
                    maxBuffer: 1024 * 1024,
                    shell: '/bin/bash'
                });
                const execDuration = Date.now() - execStart;
                console.log(`[Send Command Tool] ⏱️  Command completed in ${execDuration}ms`);
                // Combine stdout and stderr
                let output = '';
                if (stdout) {
                    output += stdout;
                }
                if (stderr) {
                    output += (output ? '\n' : '') + `[STDERR]: ${stderr}`;
                }
                if (!output) {
                    output = 'Command executed successfully with no output.';
                }
                // Truncate very long output
                if (output.length > 4000) {
                    output = output.substring(0, 4000) + '\n\n... (output truncated)';
                }
                const totalDuration = Date.now() - startTime;
                console.log(`[Send Command Tool] ⏱️  Total execution time: ${totalDuration}ms`);
                return `Command: ${command}\n\nOutput:\n${output}`;
            } catch (error) {
                const totalDuration = Date.now() - startTime;
                console.error(`[Send Command Tool] ⏱️  Error after ${totalDuration}ms:`, error);
                // Handle timeout
                if (error.killed && error.signal === 'SIGTERM') {
                    return `Error: Command timed out after ${timeout}ms`;
                }
                // Handle command execution errors
                let errorMessage = `Error executing command: ${command}\n\n`;
                if (error.stdout) {
                    errorMessage += `STDOUT:\n${error.stdout}\n\n`;
                }
                if (error.stderr) {
                    errorMessage += `STDERR:\n${error.stderr}\n\n`;
                }
                if (error.code) {
                    errorMessage += `Exit code: ${error.code}`;
                }
                return errorMessage.trim();
            }
        });
    }
}
exports.sendCommandTool = new SendCommandTool(); // Type assertion for export
}),
"[project]/node_modules/@redbtn/ai/dist/lib/tools/scrape_url.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.scrapeUrlTool = void 0;
const tools_1 = __turbopack_context__.r("[project]/node_modules/@langchain/core/tools.cjs [app-route] (ecmascript)");
const zod_1 = __turbopack_context__.r("[project]/node_modules/zod/index.cjs [app-route] (ecmascript)");
const urlSchema = zod_1.z.object({
    url: zod_1.z.string().describe("The URL to scrape (must be http or https)")
});
class ScrapeUrlTool extends tools_1.StructuredTool {
    constructor(){
        super(...arguments);
        this.name = "scrape_url";
        this.description = "Fetch and extract text content from a webpage. Returns the main body text from the URL, limited to 1000 tokens.";
        this.schema = urlSchema;
    }
    _call(_a) {
        return __awaiter(this, arguments, void 0, function*({ url }) {
            const startTime = Date.now();
            try {
                let validUrl;
                try {
                    validUrl = new URL(url);
                } catch (_b) {
                    return `Error: Invalid URL format: ${url}`;
                }
                if (![
                    'http:',
                    'https:'
                ].includes(validUrl.protocol)) {
                    return `Error: Only HTTP and HTTPS protocols are allowed`;
                }
                console.log(`[Scrape URL Tool] Fetching: ${url}`);
                const response = yield fetch(url, {
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (compatible; RedBot/1.0; +https://redbtn.io)'
                    },
                    signal: AbortSignal.timeout(10000)
                });
                if (!response.ok) {
                    return `Error: HTTP ${response.status} ${response.statusText}`;
                }
                const contentType = response.headers.get('content-type') || '';
                if (!contentType.includes('text/html') && !contentType.includes('text/plain')) {
                    return `Error: URL does not return HTML or text content (got: ${contentType})`;
                }
                const html = yield response.text();
                const textContent = extractTextFromHtml(html);
                if (!textContent.trim()) {
                    return `Error: No text content found on the page`;
                }
                const truncated = truncateToTokens(textContent, 1000);
                const duration = Date.now() - startTime;
                console.log(`[Scrape URL Tool] ⏱️  Scraped successfully in ${duration}ms (${truncated.length} chars)`);
                return `Content from ${url}:\n\n${truncated}`;
            } catch (error) {
                const duration = Date.now() - startTime;
                console.error(`[Scrape URL Tool] ⏱️  Error after ${duration}ms:`, error);
                if (error.name === 'AbortError' || error.name === 'TimeoutError') {
                    return `Error: Request timed out after 10 seconds`;
                }
                return `Error scraping URL: ${error instanceof Error ? error.message : String(error)}`;
            }
        });
    }
}
function extractTextFromHtml(html) {
    let text = html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, ' ');
    text = text.replace(/<style\b[^<]*(?:(?!<\/style>)<[^<]*)*<\/style>/gi, ' ');
    text = text.replace(/<!--[\s\S]*?-->/g, ' ');
    text = text.replace(/<[^>]+>/g, ' ');
    text = text.replace(/&nbsp;/g, ' ');
    text = text.replace(/&amp;/g, '&');
    text = text.replace(/&lt;/g, '<');
    text = text.replace(/&gt;/g, '>');
    text = text.replace(/&quot;/g, '"');
    text = text.replace(/&#39;/g, "'");
    text = text.replace(/&mdash;/g, '—');
    text = text.replace(/&ndash;/g, '–');
    text = text.replace(/\s+/g, ' ');
    text = text.trim();
    return text;
}
function truncateToTokens(text, maxTokens) {
    try {
        // Lazy-load tiktoken to avoid build-time issues with WASM
        const { encoding_for_model } = __turbopack_context__.r("[project]/node_modules/tiktoken/tiktoken.cjs [app-route] (ecmascript)");
        const encoding = encoding_for_model('gpt-3.5-turbo');
        const tokens = encoding.encode(text);
        if (tokens.length <= maxTokens) {
            encoding.free();
            return text;
        }
        const truncatedTokens = tokens.slice(0, maxTokens);
        const truncated = new TextDecoder().decode(encoding.decode(truncatedTokens));
        encoding.free();
        return truncated + '\n\n... (content truncated to 1000 tokens)';
    } catch (error) {
        // Fallback if tiktoken fails to load (e.g., in browser environments)
        const estimatedChars = maxTokens * 4;
        if (text.length <= estimatedChars) {
            return text;
        }
        return text.substring(0, estimatedChars) + '\n\n... (content truncated to ~1000 tokens)';
    }
}
exports.scrapeUrlTool = new ScrapeUrlTool();
}),
"[project]/node_modules/@redbtn/ai/dist/lib/tools/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * @file src/lib/tools/index.ts
 * @description Central registry for all AI tools available to the Red agent
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.scrapeUrlTool = exports.sendCommandTool = exports.webSearchTool = exports.allTools = void 0;
const search_web_1 = __turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/lib/tools/search_web.js [app-route] (ecmascript)");
Object.defineProperty(exports, "webSearchTool", {
    enumerable: true,
    get: function() {
        return search_web_1.webSearchTool;
    }
});
const send_command_1 = __turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/lib/tools/send_command.js [app-route] (ecmascript)");
Object.defineProperty(exports, "sendCommandTool", {
    enumerable: true,
    get: function() {
        return send_command_1.sendCommandTool;
    }
});
const scrape_url_1 = __turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/lib/tools/scrape_url.js [app-route] (ecmascript)");
Object.defineProperty(exports, "scrapeUrlTool", {
    enumerable: true,
    get: function() {
        return scrape_url_1.scrapeUrlTool;
    }
});
/**
 * Array of all available tools that can be bound to the LLM.
 * These are action tools that should only be used when necessary.
 */ exports.allTools = [
    search_web_1.webSearchTool,
    send_command_1.sendCommandTool,
    scrape_url_1.scrapeUrlTool
];
}),
"[project]/node_modules/@redbtn/ai/dist/lib/nodes/tool.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toolNode = void 0;
const prebuilt_1 = __turbopack_context__.r("[project]/node_modules/@langchain/langgraph/prebuilt.cjs [app-route] (ecmascript)");
const tools_1 = __turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/lib/tools/index.js [app-route] (ecmascript)");
/**
 * Tool execution node using LangGraph's built-in ToolNode
 * Automatically handles tool execution based on tool_calls from the LLM
 */ exports.toolNode = new prebuilt_1.ToolNode(tools_1.allTools);
}),
"[project]/node_modules/@redbtn/ai/dist/lib/nodes/toolPicker.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toolPickerNode = toolPickerNode;
const tools_1 = __turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/lib/tools/index.js [app-route] (ecmascript)");
const messages_1 = __turbopack_context__.r("[project]/node_modules/@langchain/core/messages.cjs [app-route] (ecmascript)");
const thinking_1 = __turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/lib/utils/thinking.js [app-route] (ecmascript)");
/**
 * The toolPicker node executes web_search tool before routing to chat.
 * This provides the chat node with fresh context without exposing tools
 * to conversational queries, preserving streaming.
 *
 * @param state The current state of the graph.
 * @returns A partial state with tool results added to messages.
 */ function toolPickerNode(state) {
    return __awaiter(this, void 0, void 0, function*() {
        var _a, _b, _c;
        const query = ((_a = state.query) === null || _a === void 0 ? void 0 : _a.message) || '';
        const redInstance = state.redInstance;
        const toolAction = state.toolAction || 'web_search';
        const toolParam = state.toolParam || '';
        const generationId = (_b = state.options) === null || _b === void 0 ? void 0 : _b.generationId;
        const conversationId = (_c = state.options) === null || _c === void 0 ? void 0 : _c.conversationId;
        try {
            // Log tool execution start
            const toolEmojis = {
                'web_search': '🔍',
                'scrape_url': '📄',
                'system_command': '⚙️'
            };
            const emoji = toolEmojis[toolAction] || '🔧';
            yield redInstance.logger.log({
                level: 'info',
                category: 'tool',
                message: `<yellow>${emoji} Executing tool:</yellow> <bold>${toolAction}</bold>`,
                generationId,
                conversationId,
                metadata: {
                    tool: toolAction,
                    param: toolParam
                }
            });
            let result = '';
            let toolUsed = toolAction;
            let searchQuery = query; // Default to original query
            // For web_search, let LLM optimize the search terms
            if (toolAction === 'web_search') {
                yield redInstance.logger.log({
                    level: 'debug',
                    category: 'tool',
                    message: `<dim>Optimizing search query...</dim>`,
                    generationId,
                    conversationId
                });
                const currentDate = new Date().toLocaleDateString('en-US', {
                    weekday: 'long',
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
                const searchOptimization = yield redInstance.localModel.invoke([
                    {
                        role: 'system',
                        content: `Today's date: ${currentDate}. You are a search query optimizer. Extract the key search terms from the user's question. Return ONLY the optimized search query, nothing else.

Examples:
"What baseball games are happening tonight?" → "MLB games today schedule"
"Who won the election last week?" → "election results 2025"
"What's the weather like in Paris?" → "Paris weather today"
"Tell me about the new iPhone" → "latest iPhone 2025 features"`
                    },
                    {
                        role: 'user',
                        content: query
                    }
                ]);
                const { thinking, cleanedContent } = (0, thinking_1.extractThinking)(searchOptimization.content.toString());
                // Log optimization thinking
                if (thinking && generationId && conversationId) {
                    yield redInstance.logger.logThought({
                        content: thinking,
                        source: 'toolPicker-search-optimization',
                        generationId,
                        conversationId
                    });
                }
                (0, thinking_1.logThinking)(thinking, 'ToolPicker (Search Optimization)');
                searchQuery = cleanedContent.trim();
                yield redInstance.logger.log({
                    level: 'info',
                    category: 'tool',
                    message: `<cyan>Optimized search:</cyan> <dim>"${query.substring(0, 40)}${query.length > 40 ? '...' : ''}"</dim> → <green>"${searchQuery}"</green>`,
                    generationId,
                    conversationId,
                    metadata: {
                        originalQuery: query,
                        optimizedQuery: searchQuery
                    }
                });
            }
            // Execute the specific tool the router chose
            if (toolAction === 'web_search') {
                const webSearchTool = tools_1.allTools.find((t)=>t.name === 'web_search');
                if (!webSearchTool) {
                    yield redInstance.logger.log({
                        level: 'error',
                        category: 'tool',
                        message: `<red>✗ Tool not found:</red> web_search`,
                        generationId,
                        conversationId
                    });
                    return {
                        selectedTools: [],
                        messages: [],
                        toolStatus: 'error: tool not found'
                    };
                }
                result = yield webSearchTool.invoke({
                    query: searchQuery
                });
            } else if (toolAction === 'scrape_url') {
                const scrapeTool = tools_1.allTools.find((t)=>t.name === 'scrape_url');
                if (!scrapeTool) {
                    yield redInstance.logger.log({
                        level: 'error',
                        category: 'tool',
                        message: `<red>✗ Tool not found:</red> scrape_url`,
                        generationId,
                        conversationId
                    });
                    return {
                        selectedTools: [],
                        messages: [],
                        toolStatus: 'error: tool not found'
                    };
                }
                const urlToScrape = toolParam || query;
                yield redInstance.logger.log({
                    level: 'debug',
                    category: 'tool',
                    message: `<dim>Scraping URL: ${urlToScrape}</dim>`,
                    generationId,
                    conversationId
                });
                result = yield scrapeTool.invoke({
                    url: urlToScrape
                });
            } else if (toolAction === 'system_command') {
                const commandTool = tools_1.allTools.find((t)=>t.name === 'send_command');
                if (!commandTool) {
                    yield redInstance.logger.log({
                        level: 'error',
                        category: 'tool',
                        message: `<red>✗ Tool not found:</red> send_command`,
                        generationId,
                        conversationId
                    });
                    return {
                        selectedTools: [],
                        messages: [],
                        toolStatus: 'error: tool not found'
                    };
                }
                const command = toolParam || query;
                yield redInstance.logger.log({
                    level: 'debug',
                    category: 'tool',
                    message: `<dim>Executing command: ${command}</dim>`,
                    generationId,
                    conversationId
                });
                result = yield commandTool.invoke({
                    command
                });
            }
            // Log tool completion
            yield redInstance.logger.log({
                level: 'success',
                category: 'tool',
                message: `<green>✓ Tool completed:</green> <bold>${toolAction}</bold> <dim>(${result.length} chars)</dim>`,
                generationId,
                conversationId,
                metadata: {
                    tool: toolAction,
                    resultLength: result.length
                }
            });
            // Extract and summarize the information
            yield redInstance.logger.log({
                level: 'debug',
                category: 'tool',
                message: `<dim>Extracting key information...</dim>`,
                generationId,
                conversationId
            });
            const currentDate = new Date().toLocaleDateString('en-US', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
            const extractedInfo = yield redInstance.localModel.invoke([
                {
                    role: 'system',
                    content: `Today's date: ${currentDate}. You are an information extraction expert. Extract key facts and data to answer the user's query accurately and concisely.`
                },
                {
                    role: 'user',
                    content: `User Query: ${query}\n\nTool Results:\n${result}\n\nExtract and summarize the key information that answers this query:`
                }
            ]);
            let summary = extractedInfo.content.toString().trim();
            // Extract and log thinking if present (safe for all models)
            const { thinking, cleanedContent } = (0, thinking_1.extractThinking)(summary);
            // Log extraction thinking
            if (thinking && generationId && conversationId) {
                yield redInstance.logger.logThought({
                    content: thinking,
                    source: 'toolPicker-extraction',
                    generationId,
                    conversationId
                });
            }
            (0, thinking_1.logThinking)(thinking, 'ToolPicker');
            summary = cleanedContent;
            yield redInstance.logger.log({
                level: 'success',
                category: 'tool',
                message: `<green>✓ Information extracted</green> <dim>(${summary.length} chars)</dim>`,
                generationId,
                conversationId,
                metadata: {
                    summaryLength: summary.length
                }
            });
            // Add extracted/summarized info as a SystemMessage
            return {
                selectedTools: [
                    toolUsed
                ],
                messages: [
                    new messages_1.SystemMessage(`[INTERNAL CONTEXT - User cannot see this]\nRelevant information found:\n\n${summary}\n\nUse this information to answer the user's query directly and confidently. Do not say "according to search results" or reference external sources - answer as if you know this information.`)
                ]
            };
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            yield redInstance.logger.log({
                level: 'error',
                category: 'tool',
                message: `<red>✗ Tool execution error:</red> ${errorMessage}`,
                generationId,
                conversationId,
                metadata: {
                    error: errorMessage,
                    tool: toolAction
                }
            });
            return {
                selectedTools: [],
                messages: []
            };
        }
    });
}
}),
"[project]/node_modules/@redbtn/ai/dist/lib/graphs/red.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.redGraph = void 0;
const langgraph_1 = __turbopack_context__.r("[project]/node_modules/@langchain/langgraph/index.cjs [app-route] (ecmascript)");
const router_1 = __turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/lib/nodes/router.js [app-route] (ecmascript)");
const chat_1 = __turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/lib/nodes/chat.js [app-route] (ecmascript)");
const tool_1 = __turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/lib/nodes/tool.js [app-route] (ecmascript)");
const toolPicker_1 = __turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/lib/nodes/toolPicker.js [app-route] (ecmascript)");
/**
 * 1. Define the State using Annotation
 * This is the shared memory object that flows between nodes.
 */ const RedGraphState = langgraph_1.Annotation.Root({
    query: (0, langgraph_1.Annotation)({
        reducer: (x, y)=>y,
        default: ()=>({})
    }),
    options: (0, langgraph_1.Annotation)({
        reducer: (x, y)=>y,
        default: ()=>({})
    }),
    // Carry the Red instance through the graph so nodes can access configured models
    redInstance: (0, langgraph_1.Annotation)({
        reducer: (x, y)=>y,
        default: ()=>({})
    }),
    // Messages array that accumulates throughout the tool calling loop
    messages: (0, langgraph_1.Annotation)({
        reducer: (x, y)=>x.concat(y),
        default: ()=>[]
    }),
    // Response contains the full AIMessage object with content, tokens, and metadata
    response: (0, langgraph_1.Annotation)({
        reducer: (x, y)=>y
    }),
    nextGraph: (0, langgraph_1.Annotation)({
        reducer: (x, y)=>y
    }),
    // Track which tools were selected by toolPicker for this query
    selectedTools: (0, langgraph_1.Annotation)({
        reducer: (x, y)=>y,
        default: ()=>[]
    })
});
// --- Graph Definition ---
// Helper function to determine if we should continue to tools or end
function shouldContinue(state) {
    var _a;
    const toolCalls = (_a = state.response) === null || _a === void 0 ? void 0 : _a.tool_calls;
    // If the LLM makes tool calls, route to the tools node for execution
    if (toolCalls && toolCalls.length > 0) {
        return "tools";
    }
    // Otherwise, end the graph (no tools to execute)
    return langgraph_1.END;
}
// Create a new graph instance
const redGraphBuilder = new langgraph_1.StateGraph(RedGraphState).addNode("router", router_1.routerNode).addNode("toolPicker", toolPicker_1.toolPickerNode) // Pre-filter and execute tools if needed
.addNode("chat", chat_1.chatNode).addNode("tools", tool_1.toolNode) // For follow-up tool calls from chat
.addEdge("__start__", "router").addConditionalEdges("router", (state)=>state.nextGraph || "chat", {
    "homeGraph": langgraph_1.END,
    "assistantGraph": langgraph_1.END,
    "toolPicker": "toolPicker",
    "chat": "chat"
})// After toolPicker executes tools, go to chat with results
.addEdge("toolPicker", "chat")// After chat, check if we need to call MORE tools (for follow-ups)
.addConditionalEdges("chat", shouldContinue, {
    tools: "tools",
    [langgraph_1.END]: langgraph_1.END
})// After follow-up tools, go back to chat to process results
.addEdge("tools", "chat");
// Compile the graph into a runnable object
exports.redGraph = redGraphBuilder.compile();
}),
"[project]/node_modules/@redbtn/ai/dist/functions/respond.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Response generation and streaming utilities
 */ var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
};
var __asyncValues = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__asyncValues || function(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
    //TURBOPACK unreachable
    ;
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
};
var __asyncGenerator = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
    }, i;
    //TURBOPACK unreachable
    ;
    function awaitReturn(f) {
        return function(v) {
            return Promise.resolve(v).then(f, reject);
        };
    }
    function verb(n, f) {
        if (g[n]) {
            i[n] = function(v) {
                return new Promise(function(a, b) {
                    q.push([
                        n,
                        v,
                        a,
                        b
                    ]) > 1 || resume(n, v);
                });
            };
            if (f) i[n] = f(i[n]);
        }
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.respond = respond;
const red_1 = __turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/lib/graphs/red.js [app-route] (ecmascript)");
const background = __importStar(__turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/functions/background/index.js [app-route] (ecmascript)"));
/**
 * Handles a direct, on-demand request from a user-facing application.
 * Automatically manages conversation history, memory, and summarization.
 * @param red The Red instance
 * @param query The user's input or request data (must have a 'message' property)
 * @param options Metadata about the source of the request and conversation settings
 * @returns For non-streaming: the full AIMessage object with content, tokens, metadata, and conversationId.
 *          For streaming: an async generator that yields metadata first (with conversationId), then string chunks, then finally the full AIMessage.
 */ function respond(red_2, query_1) {
    return __awaiter(this, arguments, void 0, function*(red, query, options = {}) {
        var _a, _b;
        // Generate conversation ID if not provided
        const conversationId = options.conversationId || red.memory.generateConversationId(query.message);
        // Extract messageId for Redis pub/sub (if provided)
        const messageId = options.messageId;
        console.log(`[Respond] Starting response with messageId: ${messageId || 'NONE'}, conversationId: ${conversationId}`);
        // Start a new generation (will fail if one is already in progress)
        const generationId = yield red.logger.startGeneration(conversationId);
        if (!generationId) {
            throw new Error('A generation is already in progress for this conversation');
        }
        // Store user message in memory
        yield red.memory.addMessage(conversationId, {
            role: 'user',
            content: query.message,
            timestamp: Date.now()
        });
        const initialState = {
            query,
            options: Object.assign(Object.assign({}, options), {
                conversationId,
                generationId
            }),
            redInstance: red
        };
        // Inject a system message into the graph state for every respond() call.
        // Use env override if available so this can be configured without code changes.
        const SYSTEM_PROMPT = process.env.SYSTEM_PROMPT || `You are Red, an AI assistant developed by redbtn.io.
Current date: ${new Date().toLocaleDateString()}
Device: ${((_a = options.source) === null || _a === void 0 ? void 0 : _a.device) || 'unknown'}
Application: ${((_b = options.source) === null || _b === void 0 ? void 0 : _b.application) || 'unknown'}

CRITICAL RULES:
1. NEVER mention "knowledge cutoff", "training data", "as of my knowledge", or any limitations
2. NEVER introduce yourself unless this is the FIRST message in a new conversation or you're asked to do so
3. NEVER add disclaimers like "please note" or "for the most up-to-date information", and don't repeat the query to the user
4. If you have search results, use them directly and confidently
5. Be concise and helpful - answer the question directly without extra explanations`;
        // Attach as `systemMessage` so the chat node can include it while still loading
        // memory and the user query (we avoid pre-populating `messages` which would
        // prevent chatNode from inserting memory context).
        initialState.systemMessage = SYSTEM_PROMPT;
        // Check if streaming is requested
        if (options.stream) {
            // Use LangGraph's streaming capabilities to stream through the graph
            return streamThroughGraphWithMemory(red, initialState, conversationId, generationId, messageId);
        } else {
            // Invoke the graph and return the full AIMessage
            const result = yield red_1.redGraph.invoke(initialState);
            const response = result.response;
            // Store assistant response in memory
            yield red.memory.addMessage(conversationId, {
                role: 'assistant',
                content: typeof response.content === 'string' ? response.content : JSON.stringify(response.content),
                timestamp: Date.now()
            });
            // Get message count for title generation
            const metadata = yield red.memory.getMetadata(conversationId);
            const messageCount = (metadata === null || metadata === void 0 ? void 0 : metadata.messageCount) || 0;
            // Trigger background summarization (non-blocking)
            background.summarizeInBackground(conversationId, red.memory, red.localModel);
            // Trigger background title generation (non-blocking)
            background.generateTitleInBackground(conversationId, messageCount, red.memory, red.localModel);
            // Attach conversationId to response for server access
            return Object.assign(Object.assign({}, response), {
                conversationId
            });
        }
    });
}
/**
 * Internal method to handle streaming responses through the graph with memory management.
 * Yields metadata first (with conversationId), then string chunks, then the final AIMessage object.
 * Extracts and logs thinking from models like DeepSeek-R1.
 * @private
 */ function streamThroughGraphWithMemory(red, initialState, conversationId, generationId, messageId) {
    return __asyncGenerator(this, arguments, function* streamThroughGraphWithMemory_1() {
        var _a, e_1, _b, _c;
        var _d, _e, _f, _g, _h, _j, _k;
        try {
            // Import thinking utilities
            const { extractThinking, logThinking } = yield __await(Promise.resolve().then(()=>__importStar(__turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/lib/utils/thinking.js [app-route] (ecmascript)"))));
            // Yield metadata first so server can capture conversationId and generationId immediately
            yield yield __await({
                _metadata: true,
                conversationId,
                generationId
            });
            // Emit initial status
            if (messageId) {
                yield yield __await({
                    _status: true,
                    action: 'processing',
                    description: 'Starting generation'
                });
            }
            // Use LangGraph's streamEvents to get token-level streaming
            const stream = red_1.redGraph.streamEvents(initialState, {
                version: "v1"
            });
            let finalMessage = null;
            let fullContent = '';
            let streamedTokens = false;
            let thinkingBuffer = '';
            let inThinkingTag = false;
            let eventCount = 0;
            let toolIndicatorSent = false;
            try {
                for(var _l = true, stream_1 = __asyncValues(stream), stream_1_1; stream_1_1 = yield __await(stream_1.next()), _a = stream_1_1.done, !_a; _l = true){
                    _c = stream_1_1.value;
                    _l = false;
                    const event = _c;
                    eventCount++;
                    // Detect when toolPicker node starts (tool execution indicator)
                    const nodeName = ((_d = event.metadata) === null || _d === void 0 ? void 0 : _d.langgraph_node) || '';
                    if (nodeName === 'toolPicker' && event.event === 'on_chain_start' && !toolIndicatorSent) {
                        // Only yield tool indicator ONCE at the very start
                        toolIndicatorSent = true;
                        const toolAction = initialState.toolAction || 'web_search';
                        const toolMessages = {
                            'web_search': '🔍 Searching the web...',
                            'scrape_url': '📄 Reading webpage...',
                            'system_command': '⚙️ Executing command...'
                        };
                        const indicator = toolMessages[toolAction] || '🔧 Using tool...';
                        // Yield as metadata so it can be displayed differently
                        yield yield __await({
                            _toolStatus: true,
                            status: indicator,
                            action: toolAction
                        });
                        console.log(`[Streaming] Tool indicator: ${indicator}`);
                    }
                    // Filter out LLM calls from router and toolPicker nodes (classification/tool selection)
                    // Check multiple event properties to identify the source node
                    const eventName = event.name || '';
                    const eventTags = event.tags || [];
                    const runName = ((_e = event.metadata) === null || _e === void 0 ? void 0 : _e.langgraph_node) || '';
                    // A node is router/toolPicker if any identifier contains those strings
                    const isRouterOrToolPicker = eventName.toLowerCase().includes('router') || eventName.toLowerCase().includes('toolpicker') || runName.toLowerCase().includes('router') || runName.toLowerCase().includes('toolpicker') || eventTags.some((tag)=>tag.toLowerCase().includes('router') || tag.toLowerCase().includes('toolpicker'));
                    // Yield streaming content chunks (for models that stream tokens)
                    // But only from the chat node, not router/toolPicker
                    if (event.event === "on_llm_stream" && ((_g = (_f = event.data) === null || _f === void 0 ? void 0 : _f.chunk) === null || _g === void 0 ? void 0 : _g.content) && !isRouterOrToolPicker) {
                        let content = event.data.chunk.content;
                        // Handle thinking tags in streamed content
                        // We DON'T store thinking in fullContent - it will be stored separately
                        // Only stream and store the cleaned content for conversation context
                        for(let i = 0; i < content.length; i++){
                            const char = content[i];
                            // Check for opening think tag
                            if (!inThinkingTag && content.slice(i, i + 7) === '<think>') {
                                inThinkingTag = true;
                                i += 6; // Skip the tag
                                // Emit status that thinking is starting
                                if (messageId) {
                                    yield yield __await({
                                        _status: true,
                                        action: 'thinking',
                                        description: 'Reasoning through the problem'
                                    });
                                    process.stdout.write(`[Respond] Streaming thinking: 0 chars\r`);
                                }
                                continue;
                            }
                            // Check for closing think tag
                            if (inThinkingTag && content.slice(i, i + 8) === '</think>') {
                                if (messageId) {
                                    process.stdout.write(`\n[Respond] Thinking complete: ${thinkingBuffer.length} chars\n`);
                                }
                                inThinkingTag = false;
                                i += 7; // Skip the tag
                                // Log the accumulated thinking
                                if (thinkingBuffer.trim()) {
                                    logThinking(thinkingBuffer.trim(), 'Chat (Streaming)');
                                    // Store thinking separately in database
                                    if (generationId && conversationId) {
                                        const thinkingContent = thinkingBuffer.trim();
                                        try {
                                            const db = yield __await(Promise.resolve().then(()=>__importStar(__turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/lib/memory/database.js [app-route] (ecmascript)"))).then((m)=>m.getDatabase()));
                                            const thoughtId = yield __await(db.storeThought({
                                                thoughtId: `thought_${generationId}_${Date.now()}`,
                                                conversationId,
                                                generationId,
                                                source: 'chat',
                                                content: thinkingContent,
                                                timestamp: new Date(),
                                                metadata: {
                                                    streamChunk: true
                                                }
                                            }));
                                        } catch (err) {
                                            console.error('[Respond] Failed to store streaming thinking:', err);
                                        }
                                    }
                                }
                                thinkingBuffer = '';
                                continue;
                            }
                            // Accumulate thinking or stream regular content
                            if (inThinkingTag) {
                                thinkingBuffer += char;
                                // Stream thinking character-by-character via special object
                                if (messageId) {
                                    // Update progress indicator without logging each character
                                    if (thinkingBuffer.length % 100 === 0) {
                                        process.stdout.write(`[Respond] Streaming thinking: ${thinkingBuffer.length} chars\r`);
                                    }
                                    yield yield __await({
                                        _thinkingChunk: true,
                                        content: char
                                    });
                                }
                            } else {
                                // Skip leading whitespace at the start of content
                                if (!streamedTokens && (char === '\n' || char === '\r' || char === ' ')) {
                                    continue;
                                }
                                fullContent += char;
                                streamedTokens = true;
                                yield yield __await(char); // Only stream non-thinking content
                            }
                        }
                    }
                    // Capture the final message when LLM completes - use on_llm_end
                    // Only from chat node
                    if (event.event === "on_llm_end" && !isRouterOrToolPicker) {
                        // The AIMessage is nested in the generations array
                        const generations = (_j = (_h = event.data) === null || _h === void 0 ? void 0 : _h.output) === null || _j === void 0 ? void 0 : _j.generations;
                        if (generations && generations[0] && ((_k = generations[0][0]) === null || _k === void 0 ? void 0 : _k.message)) {
                            finalMessage = generations[0][0].message;
                        }
                    }
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (!_l && !_a && (_b = stream_1.return)) yield __await(_b.call(stream_1));
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
            // If there's remaining thinking content at the end, log it
            if (thinkingBuffer.trim()) {
                logThinking(thinkingBuffer.trim(), 'Chat (Streaming)');
            }
            // If no tokens were streamed (e.g., when using tool calls like 'speak'),
            // get the final content and stream it character by character
            if (!streamedTokens && finalMessage && finalMessage.content) {
                // Extract thinking for logging (console)
                const { thinking, cleanedContent } = extractThinking(finalMessage.content);
                if (thinking) {
                    logThinking(thinking, 'Chat (Non-streamed)');
                    // Store thinking separately in database
                    if (generationId && conversationId) {
                        try {
                            const db = yield __await(Promise.resolve().then(()=>__importStar(__turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/lib/memory/database.js [app-route] (ecmascript)"))).then((m)=>m.getDatabase()));
                            const thoughtId = yield __await(db.storeThought({
                                thoughtId: `thought_${generationId}`,
                                conversationId,
                                generationId,
                                source: 'chat',
                                content: thinking,
                                timestamp: new Date(),
                                metadata: {
                                    model: red.localModel.model
                                }
                            }));
                            console.log(`[Respond] Stored thinking: ${thoughtId}`);
                            // Publish to Redis for real-time updates
                            if (messageId) {
                                console.log(`[Respond] Publishing non-stream thinking to Redis for messageId: ${messageId}, length: ${thinking.length}`);
                                yield __await(red.messageQueue.publishThinking(messageId, thinking));
                                console.log(`[Respond] Published non-stream thinking successfully`);
                            } else {
                                console.warn(`[Respond] No messageId provided for non-stream thinking`);
                            }
                        } catch (err) {
                            console.error('[Respond] Failed to store non-streamed thinking:', err);
                        }
                    }
                }
                // Use CLEANED content (thinking will be stored separately)
                fullContent = cleanedContent;
                // Stream the cleaned content for UX
                const words = cleanedContent.split(' ');
                for(let i = 0; i < words.length; i++){
                    const word = words[i];
                    yield yield __await(i === 0 ? word : ' ' + word);
                    // Small delay for smooth streaming effect (optional)
                    yield __await(new Promise((resolve)=>setTimeout(resolve, 20)));
                }
            }
            // Store assistant response in memory (after streaming completes)
            if (fullContent) {
                // Store content in memory for LLM context (already cleaned in streaming/non-streaming paths)
                yield __await(red.memory.addMessage(conversationId, {
                    role: 'assistant',
                    content: fullContent,
                    timestamp: Date.now()
                }));
                // Complete the generation
                yield __await(red.logger.completeGeneration(generationId, {
                    response: fullContent,
                    thinking: thinkingBuffer || undefined,
                    route: initialState.toolAction || 'chat',
                    toolsUsed: initialState.selectedTools,
                    model: red.localModel.model,
                    tokens: finalMessage === null || finalMessage === void 0 ? void 0 : finalMessage.usage_metadata
                }));
                // Get message count for title generation
                const metadata = yield __await(red.memory.getMetadata(conversationId));
                const messageCount = (metadata === null || metadata === void 0 ? void 0 : metadata.messageCount) || 0;
                // Trigger background summarization (non-blocking)
                background.summarizeInBackground(conversationId, red.memory, red.localModel);
                // Trigger background title generation (non-blocking)
                background.generateTitleInBackground(conversationId, messageCount, red.memory, red.localModel);
                // Trigger executive summary generation after 3rd+ message (non-blocking)
                if (messageCount >= 3) {
                    background.generateExecutiveSummaryInBackground(conversationId, red.memory, red.localModel);
                }
            }
            // After all chunks are sent, yield the final AIMessage with complete token data
            if (finalMessage) {
                yield yield __await(finalMessage);
            }
        } catch (error) {
            // Log the failure and mark generation as failed
            yield __await(red.logger.failGeneration(generationId, error instanceof Error ? error.message : String(error)));
            throw error; // Re-throw to propagate the error
        }
    });
}
}),
"[project]/node_modules/@redbtn/ai/dist/lib/logs/colors.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Color tag utilities for log messages
 *
 * Frontends can parse these tags and apply colors
 * Servers can strip them for plain text output
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ColorTags = void 0;
exports.stripColorTags = stripColorTags;
exports.parseColorTagsToAnsi = parseColorTagsToAnsi;
exports.parseColorTagsToHtml = parseColorTagsToHtml;
exports.ColorTags = {
    // Basic colors
    red: (text)=>`<red>${text}</red>`,
    green: (text)=>`<green>${text}</green>`,
    yellow: (text)=>`<yellow>${text}</yellow>`,
    blue: (text)=>`<blue>${text}</blue>`,
    magenta: (text)=>`<magenta>${text}</magenta>`,
    cyan: (text)=>`<cyan>${text}</cyan>`,
    white: (text)=>`<white>${text}</white>`,
    gray: (text)=>`<gray>${text}</gray>`,
    // Styles
    bold: (text)=>`<bold>${text}</bold>`,
    dim: (text)=>`<dim>${text}</dim>`,
    italic: (text)=>`<italic>${text}</italic>`,
    underline: (text)=>`<underline>${text}</underline>`,
    // Semantic colors
    error: (text)=>`<red>${text}</red>`,
    success: (text)=>`<green>${text}</green>`,
    warning: (text)=>`<yellow>${text}</yellow>`,
    info: (text)=>`<cyan>${text}</cyan>`,
    debug: (text)=>`<dim>${text}</dim>`
};
/**
 * Strip all color tags from text
 */ function stripColorTags(text) {
    return text.replace(/<\/?[a-z]+>/gi, '');
}
/**
 * Parse color tags into ANSI codes for terminal output
 */ function parseColorTagsToAnsi(text) {
    const ansiCodes = {
        red: '\x1b[31m',
        green: '\x1b[32m',
        yellow: '\x1b[33m',
        blue: '\x1b[34m',
        magenta: '\x1b[35m',
        cyan: '\x1b[36m',
        white: '\x1b[37m',
        gray: '\x1b[90m',
        bold: '\x1b[1m',
        dim: '\x1b[2m',
        italic: '\x1b[3m',
        underline: '\x1b[4m'
    };
    const reset = '\x1b[0m';
    let result = text;
    // Replace opening tags
    for (const [tag, code] of Object.entries(ansiCodes)){
        result = result.replace(new RegExp(`<${tag}>`, 'gi'), code);
    }
    // Replace closing tags
    result = result.replace(/<\/[a-z]+>/gi, reset);
    return result;
}
/**
 * Parse color tags to HTML/CSS
 */ function parseColorTagsToHtml(text) {
    const htmlColors = {
        red: 'color: #ef4444',
        green: 'color: #10b981',
        yellow: 'color: #f59e0b',
        blue: 'color: #3b82f6',
        magenta: 'color: #a855f7',
        cyan: 'color: #06b6d4',
        white: 'color: #ffffff',
        gray: 'color: #6b7280',
        bold: 'font-weight: bold',
        dim: 'opacity: 0.6',
        italic: 'font-style: italic',
        underline: 'text-decoration: underline'
    };
    let result = text;
    // Replace opening tags with spans
    for (const [tag, style] of Object.entries(htmlColors)){
        result = result.replace(new RegExp(`<${tag}>`, 'gi'), `<span style="${style}">`);
    }
    // Replace closing tags
    result = result.replace(/<\/[a-z]+>/gi, '</span>');
    return result;
}
}),
"[project]/node_modules/@redbtn/ai/dist/lib/logs/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Red AI Logging System
 *
 * The most fantastic logging system known to man.
 */ var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/lib/logs/types.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/lib/logs/logger.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/lib/logs/colors.js [app-route] (ecmascript)"), exports);
}),
"[project]/node_modules/@redbtn/ai/dist/lib/logs/persistent-logger.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PersistentLogger = void 0;
const logger_1 = __turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/lib/logs/logger.js [app-route] (ecmascript)");
const database_1 = __turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/lib/memory/database.js [app-route] (ecmascript)");
/**
 * Enhanced Logger with MongoDB persistence
 *
 * Features:
 * - All original Logger functionality (Redis pub/sub, 30-day TTL)
 * - Async batch writes to MongoDB (5-second intervals)
 * - 6-month TTL in MongoDB (automatic cleanup)
 * - Graceful error handling (Redis always succeeds even if MongoDB fails)
 * - Automatic flush on shutdown
 */ class PersistentLogger extends logger_1.Logger {
    constructor(redis, nodeId = 'default'){
        super(redis);
        this.db = (0, database_1.getDatabase)();
        this.logQueue = [];
        this.generationQueue = new Map();
        this.flushInterval = null;
        this.FLUSH_INTERVAL_MS = 5000; // 5 seconds
        this.MAX_BATCH_SIZE = 100;
        this.nodeId = nodeId;
        this.startFlushInterval();
    }
    /**
     * Start the automatic flush interval
     */ startFlushInterval() {
        this.flushInterval = setInterval(()=>__awaiter(this, void 0, void 0, function*() {
                yield this.flushQueues();
            }), this.FLUSH_INTERVAL_MS);
    }
    /**
     * Flush queued logs and generations to MongoDB
     */ flushQueues() {
        return __awaiter(this, void 0, void 0, function*() {
            // Flush logs
            if (this.logQueue.length > 0) {
                const batch = this.logQueue.splice(0, this.logQueue.length);
                try {
                    yield this.db.storeLogs(batch);
                    console.log(`[PersistentLogger] Persisted ${batch.length} logs to MongoDB`);
                } catch (error) {
                    console.error('[PersistentLogger] Failed to persist logs to MongoDB:', error);
                // Don't re-queue to avoid infinite growth on persistent failures
                }
            }
            // Flush generations
            if (this.generationQueue.size > 0) {
                const generations = Array.from(this.generationQueue.values());
                this.generationQueue.clear();
                for (const gen of generations){
                    try {
                        // Check if generation exists, update if it does, insert if not
                        const existing = yield this.db.getGeneration(gen.generationId);
                        if (existing) {
                            yield this.db.updateGenerationStatus(gen.generationId, gen.status, {
                                endTime: gen.endTime,
                                duration: gen.duration,
                                error: gen.error
                            });
                        } else {
                            yield this.db.storeGeneration(gen);
                        }
                    } catch (error) {
                        console.error(`[PersistentLogger] Failed to persist generation ${gen.generationId}:`, error);
                    }
                }
                if (generations.length > 0) {
                    console.log(`[PersistentLogger] Persisted ${generations.length} generation(s) to MongoDB`);
                }
            }
        });
    }
    /**
     * Convert LogEntry to StoredLog format
     */ convertToStoredLog(logEntry) {
        return {
            logId: logEntry.id,
            generationId: logEntry.generationId,
            conversationId: logEntry.conversationId,
            level: this.mapLogLevel(logEntry.level),
            category: logEntry.category,
            message: logEntry.message,
            timestamp: new Date(logEntry.timestamp),
            nodeId: this.nodeId,
            metadata: logEntry.metadata
        };
    }
    /**
     * Map log levels to StoredLog format
     */ mapLogLevel(level) {
        const mapped = {
            'info': 'info',
            'warn': 'warn',
            'error': 'error',
            'debug': 'debug',
            'trace': 'trace',
            // Fallback
            'log': 'info'
        };
        return mapped[level] || 'info';
    }
    /**
     * Override log method to also queue for MongoDB persistence
     */ log(params) {
        const _super = Object.create(null, {
            log: {
                get: ()=>super.log
            }
        });
        return __awaiter(this, void 0, void 0, function*() {
            // Call parent method (writes to Redis, publishes to pub/sub)
            yield _super.log.call(this, params);
            // Queue for MongoDB persistence
            try {
                const storedLog = this.convertToStoredLog({
                    id: `log_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`,
                    timestamp: Date.now(),
                    level: params.level,
                    category: params.category,
                    message: params.message,
                    generationId: params.generationId,
                    conversationId: params.conversationId,
                    metadata: params.metadata
                });
                this.logQueue.push(storedLog);
                // Flush immediately if queue is too large
                if (this.logQueue.length >= this.MAX_BATCH_SIZE) {
                    yield this.flushQueues();
                }
            } catch (error) {
                console.error('[PersistentLogger] Failed to queue log for MongoDB:', error);
            // Don't throw - Redis write already succeeded
            }
        });
    }
    /**
     * Override startGeneration to also track in MongoDB
     */ startGeneration(conversationId, generationId) {
        const _super = Object.create(null, {
            startGeneration: {
                get: ()=>super.startGeneration
            }
        });
        return __awaiter(this, void 0, void 0, function*() {
            const genId = yield _super.startGeneration.call(this, conversationId, generationId);
            if (genId) {
                try {
                    // Queue generation for MongoDB
                    const dbGeneration = {
                        generationId: genId,
                        conversationId,
                        status: 'pending',
                        nodeId: this.nodeId,
                        startTime: new Date()
                    };
                    this.generationQueue.set(genId, dbGeneration);
                } catch (error) {
                    console.error('[PersistentLogger] Failed to queue generation for MongoDB:', error);
                // Don't throw - Redis write already succeeded
                }
            }
            return genId;
        });
    }
    /**
     * Override completeGeneration to track in MongoDB
     */ completeGeneration(generationId, data) {
        const _super = Object.create(null, {
            completeGeneration: {
                get: ()=>super.completeGeneration
            }
        });
        return __awaiter(this, void 0, void 0, function*() {
            var _a;
            yield _super.completeGeneration.call(this, generationId, data);
            try {
                const existing = this.generationQueue.get(generationId);
                if (existing) {
                    existing.status = 'completed';
                    existing.endTime = new Date();
                    existing.duration = existing.endTime.getTime() - existing.startTime.getTime();
                    if (data.tokens) {
                        existing.tokensUsed = data.tokens.total || 0;
                    }
                    existing.model = data.model;
                } else {
                    // Create completed entry
                    this.generationQueue.set(generationId, {
                        generationId,
                        conversationId: '',
                        status: 'completed',
                        nodeId: this.nodeId,
                        model: data.model,
                        startTime: new Date(),
                        endTime: new Date(),
                        duration: 0,
                        tokensUsed: ((_a = data.tokens) === null || _a === void 0 ? void 0 : _a.total) || 0
                    });
                }
                // Flush immediately on completion
                yield this.flushQueues();
            } catch (error) {
                console.error('[PersistentLogger] Failed to complete generation in MongoDB:', error);
            }
        });
    }
    /**
     * Override failGeneration to track in MongoDB
     */ failGeneration(generationId, error) {
        const _super = Object.create(null, {
            failGeneration: {
                get: ()=>super.failGeneration
            }
        });
        return __awaiter(this, void 0, void 0, function*() {
            yield _super.failGeneration.call(this, generationId, error);
            try {
                const existing = this.generationQueue.get(generationId);
                if (existing) {
                    existing.status = 'failed';
                    existing.endTime = new Date();
                    existing.duration = existing.endTime.getTime() - existing.startTime.getTime();
                    existing.error = error;
                } else {
                    // Create failed entry
                    this.generationQueue.set(generationId, {
                        generationId,
                        conversationId: '',
                        status: 'failed',
                        nodeId: this.nodeId,
                        startTime: new Date(),
                        endTime: new Date(),
                        duration: 0,
                        error
                    });
                }
                // Flush immediately on failure
                yield this.flushQueues();
            } catch (error) {
                console.error('[PersistentLogger] Failed to mark generation as failed in MongoDB:', error);
            }
        });
    }
    /**
     * Shutdown the logger and flush all pending writes
     */ shutdown() {
        return __awaiter(this, void 0, void 0, function*() {
            console.log('[PersistentLogger] Shutting down...');
            // Stop the flush interval
            if (this.flushInterval) {
                clearInterval(this.flushInterval);
                this.flushInterval = null;
            }
            // Flush any remaining queued data
            yield this.flushQueues();
            // Close database connection
            yield this.db.close();
            console.log('[PersistentLogger] Shutdown complete');
        });
    }
}
exports.PersistentLogger = PersistentLogger;
}),
"[project]/node_modules/@redbtn/ai/dist/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * @file src/red.ts
 * @description The core library for the Red AI agent.
 */ var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Red = exports.extractAndLogThinking = exports.logThinking = exports.extractThinking = exports.PersistentLogger = exports.MessageQueue = exports.DatabaseManager = exports.resetDatabase = exports.getDatabase = void 0;
// Load environment variables from .env early for library modules
__turbopack_context__.r("[project]/node_modules/dotenv/config.js [app-route] (ecmascript)");
const memory_1 = __turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/lib/memory/memory.js [app-route] (ecmascript)");
const queue_1 = __turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/lib/memory/queue.js [app-route] (ecmascript)");
const logger_1 = __turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/lib/logs/logger.js [app-route] (ecmascript)");
const models_1 = __turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/lib/models.js [app-route] (ecmascript)");
const background = __importStar(__turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/functions/background/index.js [app-route] (ecmascript)"));
const respond_1 = __turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/functions/respond.js [app-route] (ecmascript)");
// Export database utilities for external use
var database_1 = __turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/lib/memory/database.js [app-route] (ecmascript)");
Object.defineProperty(exports, "getDatabase", {
    enumerable: true,
    get: function() {
        return database_1.getDatabase;
    }
});
Object.defineProperty(exports, "resetDatabase", {
    enumerable: true,
    get: function() {
        return database_1.resetDatabase;
    }
});
Object.defineProperty(exports, "DatabaseManager", {
    enumerable: true,
    get: function() {
        return database_1.DatabaseManager;
    }
});
// Export message queue for background processing
var queue_2 = __turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/lib/memory/queue.js [app-route] (ecmascript)");
Object.defineProperty(exports, "MessageQueue", {
    enumerable: true,
    get: function() {
        return queue_2.MessageQueue;
    }
});
// Export logging system
__exportStar(__turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/lib/logs/index.js [app-route] (ecmascript)"), exports);
var persistent_logger_1 = __turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/lib/logs/persistent-logger.js [app-route] (ecmascript)");
Object.defineProperty(exports, "PersistentLogger", {
    enumerable: true,
    get: function() {
        return persistent_logger_1.PersistentLogger;
    }
});
// Export thinking utilities for DeepSeek-R1 and similar models
var thinking_1 = __turbopack_context__.r("[project]/node_modules/@redbtn/ai/dist/lib/utils/thinking.js [app-route] (ecmascript)");
Object.defineProperty(exports, "extractThinking", {
    enumerable: true,
    get: function() {
        return thinking_1.extractThinking;
    }
});
Object.defineProperty(exports, "logThinking", {
    enumerable: true,
    get: function() {
        return thinking_1.logThinking;
    }
});
Object.defineProperty(exports, "extractAndLogThinking", {
    enumerable: true,
    get: function() {
        return thinking_1.extractAndLogThinking;
    }
});
// --- The Red Library Class ---
/**
 * The primary class for the Red AI engine. It encapsulates the agent's
 * core logic, state management, and interaction models.
 */ class Red {
    /**
     * Constructs a new instance of the Red AI engine.
     * @param config The configuration object required for initialization.
     */ constructor(config){
        this.isLoaded = false;
        this.isThinking = false;
        this.baseState = {};
        this.config = config;
        // Initialize the model instances
        this.localModel = (0, models_1.createLocalModel)(config);
        this.openAIModel = (0, models_1.createOpenAIModel)();
        this.geminiModel = (0, models_1.createGeminiModel)();
        // Initialize memory manager
        this.memory = new memory_1.MemoryManager(config.redisUrl);
        // Initialize message queue with same Redis connection
        const redis = new (__turbopack_context__.r("[project]/node_modules/ioredis/built/index.js [app-route] (ecmascript)"))(config.redisUrl);
        this.redis = redis;
        this.messageQueue = new queue_1.MessageQueue(redis);
        // Initialize logger with same Redis connection
        this.logger = new logger_1.Logger(redis);
    }
    // --- Private Internal Methods ---
    /**
     * The internal engine that executes a specified graph with the given state and options.
     * All graph-running logic is centralized here.
     * @private
     */ _invoke(graphName, localState, options) {
        return __awaiter(this, void 0, void 0, function*() {
            if (!this.isLoaded) {
                throw new Error("Red instance is not loaded. Please call load() before invoking a graph.");
            }
            // TODO: Implement the actual LangGraph execution logic.
            // This function will select a graph from a library based on `graphName`,
            // merge the `baseState` and `localState`, and execute the graph.
            const result = {
                output: `Output from ${graphName}`,
                timestamp: new Date().toISOString()
            };
            return result;
        });
    }
    // --- Public API ---
    /**
     * Initializes the Red instance by connecting to data sources and loading the base state.
     * This method must be called before any other operations.
     * @param nodeId An optional identifier for this specific instance, used for distributed systems.
     */ load(nodeId) {
        return __awaiter(this, void 0, void 0, function*() {
            if (this.isLoaded) {
                return;
            }
            if (nodeId) {
                this.nodeId = nodeId;
            } else {
                // Generate a default nodeId if not provided
                this.nodeId = `node_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
            }
            console.log(`Loading base state for node: ${this.nodeId}...`);
            // TODO: Implement the actual state fetching logic from Redis using `this.config.redisUrl`.
            // The `nodeId` can be used to fetch a specific state for recovery or distributed operation.
            this.baseState = {
                loadedAt: new Date(),
                nodeId: this.nodeId
            };
            this.isLoaded = true;
            // Start heartbeat to register node as active
            this.heartbeatInterval = background.startHeartbeat(this.nodeId, this.redis);
            console.log('Base state loaded successfully.');
        });
    }
    /**
     * Gets a list of all currently active nodes.
     * @returns Array of active node IDs
     */ getActiveNodes() {
        return __awaiter(this, void 0, void 0, function*() {
            return background.getActiveNodes(this.redis);
        });
    }
    /**
     * Starts the autonomous, continuous "thinking" loop. The loop runs internally
     * until `stopThinking()` is called.
     */ think() {
        return __awaiter(this, void 0, void 0, function*() {
            if (!this.isLoaded) {
                throw new Error("Red instance is not loaded. Please call load() before thinking.");
            }
            if (this.isThinking) {
                return;
            }
            this.isThinking = true;
            do {
                yield this._invoke('cognitionGraph', {
                    cycleType: 'autonomous'
                });
                // Delay between cycles to prevent runaway processes and manage resource usage.
                yield new Promise((resolve)=>setTimeout(resolve, 2000)); // 2-second delay
            }while (this.isThinking)
        });
    }
    /**
     * Signals the internal `think()` loop to stop gracefully after completing its current cycle.
     */ stopThinking() {
        if (!this.isThinking) {
            return;
        }
        this.isThinking = false;
    }
    /**
     * Gracefully shuts down the Red instance, stopping heartbeat and cleaning up resources.
     */ shutdown() {
        return __awaiter(this, void 0, void 0, function*() {
            console.log(`[Red] Shutting down node: ${this.nodeId}...`);
            // Stop thinking if active
            this.stopThinking();
            // Stop heartbeat
            yield background.stopHeartbeat(this.nodeId, this.redis, this.heartbeatInterval);
            this.heartbeatInterval = undefined;
            // Close Redis connection
            if (this.redis) {
                yield this.redis.quit();
            }
            this.isLoaded = false;
            console.log('[Red] Shutdown complete');
        });
    }
    /**
     * Handles a direct, on-demand request from a user-facing application.
     * Automatically manages conversation history, memory, and summarization.
     * @param query The user's input or request data (must have a 'message' property)
     * @param options Metadata about the source of the request and conversation settings
     * @returns For non-streaming: the full AIMessage object with content, tokens, metadata, and conversationId.
     *          For streaming: an async generator that yields metadata first (with conversationId), then string chunks, then finally the full AIMessage.
     */ respond(query_1) {
        return __awaiter(this, arguments, void 0, function*(query, options = {}) {
            return (0, respond_1.respond)(this, query, options);
        });
    }
    /**
     * Set a custom title for a conversation (set by user)
     * This prevents automatic title generation from overwriting it
     * @param conversationId The conversation ID
     * @param title The custom title to set
     */ setConversationTitle(conversationId, title) {
        return __awaiter(this, void 0, void 0, function*() {
            return background.setConversationTitle(conversationId, title, this.memory);
        });
    }
    /**
     * Get the title for a conversation
     * @param conversationId The conversation ID
     * @returns The title or null if not set
     */ getConversationTitle(conversationId) {
        return __awaiter(this, void 0, void 0, function*() {
            return background.getConversationTitle(conversationId, this.memory);
        });
    }
}
exports.Red = Red;
}),
];

//# sourceMappingURL=node_modules_%40redbtn_ai_dist_ffcc3547._.js.map