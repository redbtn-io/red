{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 159, "column": 0}, "map": {"version":3,"sources":["file:///home/alpha/code/%40redbtn/webapp/src/lib/red.ts"],"sourcesContent":["/**\n * Red AI instance initialization for Next.js API routes\n */\nimport { Red, RedConfig } from '@redbtn/ai';\n\nconst config: RedConfig = {\n  redisUrl: process.env.REDIS_URL || \"redis://localhost:6379\",\n  vectorDbUrl: process.env.VECTOR_DB_URL || \"http://localhost:8200\",\n  databaseUrl: process.env.DATABASE_URL || \"http://localhost:5432\",\n  defaultLlmUrl: process.env.LLM_URL || \"http://localhost:11434\",\n};\n\nlet redInstance: Red | null = null;\n\n/**\n * Get or initialize the Red AI instance\n * Singleton pattern to avoid multiple initializations\n */\nexport async function getRed(): Promise<Red> {\n  if (!redInstance) {\n    redInstance = new Red(config);\n    await redInstance.load('webapp-api');\n    console.log('âœ… Red AI initialized successfully');\n  }\n  return redInstance;\n}\n\n/**\n * Synchronous access to Red instance (must be initialized first)\n * Use getRed() for guaranteed initialization\n */\nexport function getRedSync(): Red {\n  if (!redInstance) {\n    throw new Error('Red instance not initialized. Call getRed() first.');\n  }\n  return redInstance;\n}\n\n// Initialize immediately for synchronous access in API routes\n// This allows `import { red }` to work\nlet initPromise: Promise<Red> | null = null;\n\nif (!initPromise) {\n  initPromise = getRed();\n}\n\n// Export as named export for convenience\nexport const red = await initPromise;\n\n/**\n * Bearer token for API authentication\n */\nexport const BEARER_TOKEN = process.env.BEARER_TOKEN || `red_ai_sk_${Date.now()}`;\n"],"names":[],"mappings":"AAAA;;CAEC;;;;;;;;;;AACD;;AAEA,MAAM,SAAoB;IACxB,UAAU,QAAQ,GAAG,CAAC,SAAS,IAAI;IACnC,aAAa,QAAQ,GAAG,CAAC,aAAa,IAAI;IAC1C,aAAa,QAAQ,GAAG,CAAC,YAAY,IAAI;IACzC,eAAe,QAAQ,GAAG,CAAC,OAAO,IAAI;AACxC;AAEA,IAAI,cAA0B;AAMvB,eAAe;IACpB,IAAI,CAAC,aAAa;QAChB,cAAc,IAAI,wJAAG,CAAC;QACtB,MAAM,YAAY,IAAI,CAAC;QACvB,QAAQ,GAAG,CAAC;IACd;IACA,OAAO;AACT;AAMO,SAAS;IACd,IAAI,CAAC,aAAa;QAChB,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT;AAEA,8DAA8D;AAC9D,uCAAuC;AACvC,IAAI,cAAmC;AAEvC,IAAI,CAAC,aAAa;IAChB,cAAc;AAChB;AAGO,MAAM,MAAM,MAAM;AAKlB,MAAM,eAAe,QAAQ,GAAG,CAAC,YAAY,IAAI,CAAC,UAAU,EAAE,KAAK,GAAG,IAAI","debugId":null}},
    {"offset": {"line": 209, "column": 0}, "map": {"version":3,"sources":["file:///home/alpha/code/%40redbtn/webapp/src/app/api/v1/messages/%5BmessageId%5D/stream/route.ts"],"sourcesContent":["import { NextRequest } from 'next/server';\nimport { getRed } from '@/lib/red';\n\ninterface StreamEvent {\n  type: 'init' | 'chunk' | 'status' | 'thinking_chunk' | 'thinking' | 'complete' | 'error' | 'tool_status';\n  content?: string;\n  existingContent?: string;\n  metadata?: {\n    model?: string;\n    tokens?: {\n      input?: number;\n      output?: number;\n      total?: number;\n    };\n  };\n  error?: string;\n  status?: string;  // For tool_status\n  action?: string;  // For status and tool_status\n  description?: string; // For status\n}\n\n/**\n * Stream endpoint for reconnectable message generation\n * Subscribes to Redis pub/sub and streams message content via SSE\n * Handles reconnection by sending existing content first, then new chunks\n */\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: Promise<{ messageId: string }> }\n) {\n  const { messageId } = await params;\n  \n  console.log(`[Stream] Client connecting to message: ${messageId}`);\n\n  try {\n    const red = await getRed();\n    const messageQueue = red.messageQueue;\n\n    // Create SSE stream with proper cleanup\n    const encoder = new TextEncoder();\n    let messageStream: AsyncGenerator<StreamEvent, void, unknown> | null = null;\n    let isCancelled = false;\n    let controllerClosed = false;\n\n    const safeEnqueue = (data: Uint8Array): boolean => {\n      if (isCancelled || controllerClosed) return false;\n      try {\n        controller.enqueue(data);\n        return true;\n      } catch {\n        // Controller closed during enqueue\n        controllerClosed = true;\n        return false;\n      }\n    };\n\n    const safeClose = () => {\n      if (controllerClosed) return;\n      try {\n        controller.close();\n        controllerClosed = true;\n      } catch {\n        // Already closed\n        controllerClosed = true;\n      }\n    };\n\n    let controller: ReadableStreamDefaultController<Uint8Array>;\n    const stream = new ReadableStream({\n      async start(ctrl) {\n        controller = ctrl;\n        \n        try {\n          // Send initial comment to establish connection and prevent buffering\n          safeEnqueue(encoder.encode(`: connected\\n\\n`));\n          console.log(`[Stream] Connection established for ${messageId}`);\n          \n          // Mark stream as ready FIRST, before subscribing\n          // This signals to the completions endpoint that we're connected\n          await messageQueue.markStreamReady(messageId);\n          console.log(`[Stream] Marked stream ready for ${messageId}`);\n          \n          // Send another keepalive to ensure connection is fully open\n          safeEnqueue(encoder.encode(`: ready\\n\\n`));\n          \n          // Subscribe to message updates\n          messageStream = messageQueue.subscribeToMessage(messageId);\n\n          for await (const event of messageStream) {\n            // Check if stream was cancelled\n            if (isCancelled) {\n              console.log('[Stream] Stream cancelled, stopping iteration');\n              break;\n            }\n\n            if (event.type === 'init' && event.existingContent) {\n              // Send existing content in chunks for smooth display\n              console.log(`[Stream] Sending ${event.existingContent.length} chars of existing content`);\n              const chunks = event.existingContent.match(/.{1,50}/g) || [];\n              for (const chunk of chunks) {\n                if (isCancelled) break;\n                \n                const data = {\n                  type: 'content',\n                  content: chunk\n                };\n                if (!safeEnqueue(encoder.encode(`data: ${JSON.stringify(data)}\\n\\n`))) {\n                  break;\n                }\n              }\n            } else if (event.type === 'chunk') {\n              // Stream new chunk\n              const data = {\n                type: 'content',\n                content: event.content\n              };\n              if (!safeEnqueue(encoder.encode(`data: ${JSON.stringify(data)}\\n\\n`))) {\n                break;\n              }\n            } else if (event.type === 'status') {\n              // Send status update (processing, thinking, routing, etc.)\n              console.log('[SSE] Forwarding status:', event.action);\n              const data = {\n                type: 'status',\n                action: event.action,\n                description: event.description\n              };\n              safeEnqueue(encoder.encode(`data: ${JSON.stringify(data)}\\n\\n`));\n              // Force flush with comment\n              safeEnqueue(encoder.encode(`: flush\\n\\n`));\n            } else if (event.type === 'thinking_chunk') {\n              // Stream thinking character-by-character\n              const data = {\n                type: 'thinking_chunk',\n                content: event.content\n              };\n              if (!safeEnqueue(encoder.encode(`data: ${JSON.stringify(data)}\\n\\n`))) {\n                break;\n              }\n            } else if (event.type === 'thinking') {\n              // Stream thinking/reasoning content (legacy full block)\n              const data = {\n                type: 'thinking',\n                content: event.content\n              };\n              if (!safeEnqueue(encoder.encode(`data: ${JSON.stringify(data)}\\n\\n`))) {\n                break;\n              }\n            } else if (event.type === 'tool_status') {\n              // Send tool status indicator\n              const toolEvent = event as StreamEvent & { status: string; action: string };\n              const data = {\n                type: 'tool_status',\n                status: toolEvent.status,\n                action: toolEvent.action\n              };\n              safeEnqueue(encoder.encode(`data: ${JSON.stringify(data)}\\n\\n`));\n              // Force flush with comment\n              safeEnqueue(encoder.encode(`: flush\\n\\n`));\n            } else if (event.type === 'complete') {\n              // Send completion event\n              const data = {\n                type: 'complete',\n                metadata: event.metadata\n              };\n              safeEnqueue(encoder.encode(`data: ${JSON.stringify(data)}\\n\\n`));\n              safeEnqueue(encoder.encode('data: [DONE]\\n\\n'));\n              break;\n            } else if (event.type === 'error') {\n              // Send error event\n              const data = {\n                type: 'error',\n                error: event.error\n              };\n              safeEnqueue(encoder.encode(`data: ${JSON.stringify(data)}\\n\\n`));\n              break;\n            }\n          }\n\n          safeClose();\n        } catch (error) {\n          console.error('[Stream] Error:', error);\n          const data = {\n            type: 'error',\n            error: error instanceof Error ? error.message : String(error)\n          };\n          safeEnqueue(encoder.encode(`data: ${JSON.stringify(data)}\\n\\n`));\n          safeClose();\n        }\n      },\n      async cancel() {\n        console.log(`[Stream] Client disconnected from message: ${messageId}`);\n        isCancelled = true;\n        \n        // Clean up the async generator/Redis subscription\n        if (messageStream && typeof messageStream.return === 'function') {\n          try {\n            await messageStream.return();\n          } catch {\n            // Ignore cleanup errors\n          }\n        }\n      }\n    });\n\n    return new Response(stream, {\n      headers: {\n        'Content-Type': 'text/event-stream',\n        'Cache-Control': 'no-cache, no-transform',\n        'Connection': 'keep-alive',\n        'X-Accel-Buffering': 'no'\n      }\n    });\n  } catch (error) {\n    console.error('[Stream] Failed to create stream:', error);\n    return new Response(\n      JSON.stringify({\n        error: {\n          message: error instanceof Error ? error.message : 'Failed to create stream',\n          type: 'stream_error'\n        }\n      }),\n      {\n        status: 500,\n        headers: { 'Content-Type': 'application/json' }\n      }\n    );\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}