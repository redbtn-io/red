{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 171, "column": 0}, "map": {"version":3,"sources":["file:///home/alpha/code/%40redbtn/webapp/src/lib/red.ts"],"sourcesContent":["/**\n * Red AI instance initialization for Next.js API routes\n */\nimport { Red, RedConfig } from '@redbtn/ai';\n\nconst config: RedConfig = {\n  redisUrl: process.env.REDIS_URL || \"redis://localhost:6379\",\n  vectorDbUrl: process.env.VECTOR_DB_URL || \"http://localhost:8200\",\n  databaseUrl: process.env.DATABASE_URL || \"http://localhost:5432\",\n  defaultLlmUrl: process.env.LLM_URL || \"http://localhost:11434\",\n};\n\nlet redInstance: Red | null = null;\n\n/**\n * Get or initialize the Red AI instance\n * Singleton pattern to avoid multiple initializations\n */\nexport async function getRed(): Promise<Red> {\n  if (!redInstance) {\n    redInstance = new Red(config);\n    await redInstance.load('webapp-api');\n    console.log('âœ… Red AI initialized successfully');\n  }\n  return redInstance;\n}\n\n/**\n * Synchronous access to Red instance (must be initialized first)\n * Use getRed() for guaranteed initialization\n */\nexport function getRedSync(): Red {\n  if (!redInstance) {\n    throw new Error('Red instance not initialized. Call getRed() first.');\n  }\n  return redInstance;\n}\n\n// Initialize immediately for synchronous access in API routes\n// This allows `import { red }` to work\nlet initPromise: Promise<Red> | null = null;\n\nif (!initPromise) {\n  initPromise = getRed();\n}\n\n// Export as named export for convenience\nexport const red = await initPromise;\n\n/**\n * Bearer token for API authentication\n */\nexport const BEARER_TOKEN = process.env.BEARER_TOKEN || `red_ai_sk_${Date.now()}`;\n"],"names":[],"mappings":"AAAA;;CAEC;;;;;;;;;;AACD;;AAEA,MAAM,SAAoB;IACxB,UAAU,QAAQ,GAAG,CAAC,SAAS,IAAI;IACnC,aAAa,QAAQ,GAAG,CAAC,aAAa,IAAI;IAC1C,aAAa,QAAQ,GAAG,CAAC,YAAY,IAAI;IACzC,eAAe,QAAQ,GAAG,CAAC,OAAO,IAAI;AACxC;AAEA,IAAI,cAA0B;AAMvB,eAAe;IACpB,IAAI,CAAC,aAAa;QAChB,cAAc,IAAI,wJAAG,CAAC;QACtB,MAAM,YAAY,IAAI,CAAC;QACvB,QAAQ,GAAG,CAAC;IACd;IACA,OAAO;AACT;AAMO,SAAS;IACd,IAAI,CAAC,aAAa;QAChB,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT;AAEA,8DAA8D;AAC9D,uCAAuC;AACvC,IAAI,cAAmC;AAEvC,IAAI,CAAC,aAAa;IAChB,cAAc;AAChB;AAGO,MAAM,MAAM,MAAM;AAKlB,MAAM,eAAe,QAAQ,GAAG,CAAC,YAAY,IAAI,CAAC,UAAU,EAAE,KAAK,GAAG,IAAI","debugId":null}},
    {"offset": {"line": 221, "column": 0}, "map": {"version":3,"sources":["file:///home/alpha/code/%40redbtn/webapp/src/app/api/v1/conversations/%5Bid%5D/generation-state/route.ts"],"sourcesContent":["/**\n * API endpoint to get conversation generation state\n * GET /api/v1/conversations/:id/generation-state\n * \n * Returns current generation status, prevents concurrent generations\n */\n\nimport { NextRequest, NextResponse } from 'next/server';\nimport { red } from '@/lib/red';\n\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  try {\n    const { id: conversationId } = await params;\n    \n    if (!conversationId) {\n      return NextResponse.json(\n        { error: 'conversationId is required' },\n        { status: 400 }\n      );\n    }\n    \n    // Get generation state\n    const state = await red.logger.getConversationGenerationState(conversationId);\n    \n    if (!state) {\n      return NextResponse.json({\n        conversationId,\n        isGenerating: false,\n        generationCount: 0,\n      });\n    }\n    \n    // Check if current generation is still active\n    let isGenerating = false;\n    if (state.currentGenerationId) {\n      const generation = await red.logger.getGeneration(state.currentGenerationId);\n      isGenerating = generation?.status === 'generating';\n    }\n    \n    return NextResponse.json({\n      conversationId,\n      isGenerating,\n      currentGenerationId: state.currentGenerationId,\n      lastGenerationId: state.lastGenerationId,\n      generationCount: state.generationCount,\n    });\n  } catch (error) {\n    console.error('[API] Error fetching generation state:', error);\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;AAED;AACA;;;;;;;AAEO,eAAe,IACpB,OAAoB,EACpB,EAAE,MAAM,EAAuC;IAE/C,IAAI;QACF,MAAM,EAAE,IAAI,cAAc,EAAE,GAAG,MAAM;QAErC,IAAI,CAAC,gBAAgB;YACnB,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA6B,GACtC;gBAAE,QAAQ;YAAI;QAElB;QAEA,uBAAuB;QACvB,MAAM,QAAQ,MAAM,0HAAG,CAAC,MAAM,CAAC,8BAA8B,CAAC;QAE9D,IAAI,CAAC,OAAO;YACV,OAAO,gJAAY,CAAC,IAAI,CAAC;gBACvB;gBACA,cAAc;gBACd,iBAAiB;YACnB;QACF;QAEA,8CAA8C;QAC9C,IAAI,eAAe;QACnB,IAAI,MAAM,mBAAmB,EAAE;YAC7B,MAAM,aAAa,MAAM,0HAAG,CAAC,MAAM,CAAC,aAAa,CAAC,MAAM,mBAAmB;YAC3E,eAAe,YAAY,WAAW;QACxC;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB;YACA;YACA,qBAAqB,MAAM,mBAAmB;YAC9C,kBAAkB,MAAM,gBAAgB;YACxC,iBAAiB,MAAM,eAAe;QACxC;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,0CAA0C;QACxD,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAwB,GACjC;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}