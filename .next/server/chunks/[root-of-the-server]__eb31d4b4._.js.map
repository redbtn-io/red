{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 171, "column": 0}, "map": {"version":3,"sources":["file:///home/alpha/code/%40redbtn/webapp/src/lib/red.ts"],"sourcesContent":["/**\n * Red AI instance initialization for Next.js API routes\n */\nimport { Red, RedConfig } from '@redbtn/ai';\n\nconst config: RedConfig = {\n  redisUrl: process.env.REDIS_URL || \"redis://localhost:6379\",\n  vectorDbUrl: process.env.VECTOR_DB_URL || \"http://localhost:8200\",\n  databaseUrl: process.env.DATABASE_URL || \"http://localhost:5432\",\n  defaultLlmUrl: process.env.LLM_URL || \"http://localhost:11434\",\n};\n\nlet redInstance: Red | null = null;\n\n/**\n * Get or initialize the Red AI instance\n * Singleton pattern to avoid multiple initializations\n */\nexport async function getRed(): Promise<Red> {\n  if (!redInstance) {\n    redInstance = new Red(config);\n    await redInstance.load('webapp-api');\n    console.log('âœ… Red AI initialized successfully');\n  }\n  return redInstance;\n}\n\n/**\n * Synchronous access to Red instance (must be initialized first)\n * Use getRed() for guaranteed initialization\n */\nexport function getRedSync(): Red {\n  if (!redInstance) {\n    throw new Error('Red instance not initialized. Call getRed() first.');\n  }\n  return redInstance;\n}\n\n// Initialize immediately for synchronous access in API routes\n// This allows `import { red }` to work\nlet initPromise: Promise<Red> | null = null;\n\nif (!initPromise) {\n  initPromise = getRed();\n}\n\n// Export as named export for convenience\nexport const red = await initPromise;\n\n/**\n * Bearer token for API authentication\n */\nexport const BEARER_TOKEN = process.env.BEARER_TOKEN || `red_ai_sk_${Date.now()}`;\n"],"names":[],"mappings":"AAAA;;CAEC;;;;;;;;;;AACD;;AAEA,MAAM,SAAoB;IACxB,UAAU,QAAQ,GAAG,CAAC,SAAS,IAAI;IACnC,aAAa,QAAQ,GAAG,CAAC,aAAa,IAAI;IAC1C,aAAa,QAAQ,GAAG,CAAC,YAAY,IAAI;IACzC,eAAe,QAAQ,GAAG,CAAC,OAAO,IAAI;AACxC;AAEA,IAAI,cAA0B;AAMvB,eAAe;IACpB,IAAI,CAAC,aAAa;QAChB,cAAc,IAAI,wJAAG,CAAC;QACtB,MAAM,YAAY,IAAI,CAAC;QACvB,QAAQ,GAAG,CAAC;IACd;IACA,OAAO;AACT;AAMO,SAAS;IACd,IAAI,CAAC,aAAa;QAChB,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT;AAEA,8DAA8D;AAC9D,uCAAuC;AACvC,IAAI,cAAmC;AAEvC,IAAI,CAAC,aAAa;IAChB,cAAc;AAChB;AAGO,MAAM,MAAM,MAAM;AAKlB,MAAM,eAAe,QAAQ,GAAG,CAAC,YAAY,IAAI,CAAC,UAAU,EAAE,KAAK,GAAG,IAAI","debugId":null}},
    {"offset": {"line": 221, "column": 0}, "map": {"version":3,"sources":["file:///home/alpha/code/%40redbtn/webapp/src/app/api/v1/conversations/%5Bid%5D/title/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { getRed } from '@/lib/red';\n\ninterface RouteContext {\n  params: Promise<{\n    id: string;\n  }>;\n}\n\n/**\n * GET /api/v1/conversations/[id]/title\n * Fetch the conversation title from Redis (generated by Red AI)\n */\nexport async function GET(\n  _request: NextRequest,\n  context: RouteContext\n) {\n  try {\n    const { id } = await context.params;\n    const red = await getRed();\n    const title = await red.getConversationTitle(id);\n\n    return NextResponse.json({ \n      conversationId: id,\n      title: title || null \n    });\n  } catch (error) {\n    console.error('Error fetching conversation title:', error);\n    return NextResponse.json(\n      {\n        error: {\n          message: error instanceof Error ? error.message : 'Internal server error',\n          type: 'internal_error',\n          code: 'internal_error'\n        }\n      },\n      { status: 500 }\n    );\n  }\n}\n\n/**\n * PUT /api/v1/conversations/[id]/title\n * Set a custom title for the conversation (user override)\n */\nexport async function PUT(\n  request: NextRequest,\n  context: RouteContext\n) {\n  try {\n    const { id } = await context.params;\n    const body = await request.json();\n\n    if (!body.title || typeof body.title !== 'string') {\n      return NextResponse.json(\n        {\n          error: {\n            message: 'title is required and must be a string',\n            type: 'invalid_request_error',\n            code: 'invalid_title'\n          }\n        },\n        { status: 400 }\n      );\n    }\n\n    const red = await getRed();\n    await red.setConversationTitle(id, body.title);\n\n    return NextResponse.json({ \n      conversationId: id,\n      title: body.title,\n      titleSetByUser: true\n    });\n  } catch (error) {\n    console.error('Error setting conversation title:', error);\n    return NextResponse.json(\n      {\n        error: {\n          message: error instanceof Error ? error.message : 'Internal server error',\n          type: 'internal_error',\n          code: 'internal_error'\n        }\n      },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;;;;;AAYO,eAAe,IACpB,QAAqB,EACrB,OAAqB;IAErB,IAAI;QACF,MAAM,EAAE,EAAE,EAAE,GAAG,MAAM,QAAQ,MAAM;QACnC,MAAM,MAAM,MAAM,IAAA,6HAAM;QACxB,MAAM,QAAQ,MAAM,IAAI,oBAAoB,CAAC;QAE7C,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,gBAAgB;YAChB,OAAO,SAAS;QAClB;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,sCAAsC;QACpD,OAAO,gJAAY,CAAC,IAAI,CACtB;YACE,OAAO;gBACL,SAAS,iBAAiB,QAAQ,MAAM,OAAO,GAAG;gBAClD,MAAM;gBACN,MAAM;YACR;QACF,GACA;YAAE,QAAQ;QAAI;IAElB;AACF;AAMO,eAAe,IACpB,OAAoB,EACpB,OAAqB;IAErB,IAAI;QACF,MAAM,EAAE,EAAE,EAAE,GAAG,MAAM,QAAQ,MAAM;QACnC,MAAM,OAAO,MAAM,QAAQ,IAAI;QAE/B,IAAI,CAAC,KAAK,KAAK,IAAI,OAAO,KAAK,KAAK,KAAK,UAAU;YACjD,OAAO,gJAAY,CAAC,IAAI,CACtB;gBACE,OAAO;oBACL,SAAS;oBACT,MAAM;oBACN,MAAM;gBACR;YACF,GACA;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,MAAM,MAAM,IAAA,6HAAM;QACxB,MAAM,IAAI,oBAAoB,CAAC,IAAI,KAAK,KAAK;QAE7C,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,gBAAgB;YAChB,OAAO,KAAK,KAAK;YACjB,gBAAgB;QAClB;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,qCAAqC;QACnD,OAAO,gJAAY,CAAC,IAAI,CACtB;YACE,OAAO;gBACL,SAAS,iBAAiB,QAAQ,MAAM,OAAO,GAAG;gBAClD,MAAM;gBACN,MAAM;YACR;QACF,GACA;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}