{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 171, "column": 0}, "map": {"version":3,"sources":["file:///home/alpha/code/%40redbtn/webapp/src/lib/red.ts"],"sourcesContent":["/**\n * Red AI instance initialization for Next.js API routes\n */\nimport { Red, RedConfig } from '@redbtn/ai';\n\nconst config: RedConfig = {\n  redisUrl: process.env.REDIS_URL || \"redis://localhost:6379\",\n  vectorDbUrl: process.env.VECTOR_DB_URL || \"http://localhost:8200\",\n  databaseUrl: process.env.DATABASE_URL || \"http://localhost:5432\",\n  defaultLlmUrl: process.env.LLM_URL || \"http://localhost:11434\",\n};\n\nlet redInstance: Red | null = null;\n\n/**\n * Get or initialize the Red AI instance\n * Singleton pattern to avoid multiple initializations\n */\nexport async function getRed(): Promise<Red> {\n  if (!redInstance) {\n    redInstance = new Red(config);\n    await redInstance.load('webapp-api');\n    console.log('âœ… Red AI initialized successfully');\n  }\n  return redInstance;\n}\n\n/**\n * Synchronous access to Red instance (must be initialized first)\n * Use getRed() for guaranteed initialization\n */\nexport function getRedSync(): Red {\n  if (!redInstance) {\n    throw new Error('Red instance not initialized. Call getRed() first.');\n  }\n  return redInstance;\n}\n\n// Initialize immediately for synchronous access in API routes\n// This allows `import { red }` to work\nlet initPromise: Promise<Red> | null = null;\n\nif (!initPromise) {\n  initPromise = getRed();\n}\n\n// Export as named export for convenience\nexport const red = await initPromise;\n\n/**\n * Bearer token for API authentication\n */\nexport const BEARER_TOKEN = process.env.BEARER_TOKEN || `red_ai_sk_${Date.now()}`;\n"],"names":[],"mappings":"AAAA;;CAEC;;;;;;;;;;AACD;;AAEA,MAAM,SAAoB;IACxB,UAAU,QAAQ,GAAG,CAAC,SAAS,IAAI;IACnC,aAAa,QAAQ,GAAG,CAAC,aAAa,IAAI;IAC1C,aAAa,QAAQ,GAAG,CAAC,YAAY,IAAI;IACzC,eAAe,QAAQ,GAAG,CAAC,OAAO,IAAI;AACxC;AAEA,IAAI,cAA0B;AAMvB,eAAe;IACpB,IAAI,CAAC,aAAa;QAChB,cAAc,IAAI,wJAAG,CAAC;QACtB,MAAM,YAAY,IAAI,CAAC;QACvB,QAAQ,GAAG,CAAC;IACd;IACA,OAAO;AACT;AAMO,SAAS;IACd,IAAI,CAAC,aAAa;QAChB,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT;AAEA,8DAA8D;AAC9D,uCAAuC;AACvC,IAAI,cAAmC;AAEvC,IAAI,CAAC,aAAa;IAChB,cAAc;AAChB;AAGO,MAAM,MAAM,MAAM;AAKlB,MAAM,eAAe,QAAQ,GAAG,CAAC,YAAY,IAAI,CAAC,UAAU,EAAE,KAAK,GAAG,IAAI","debugId":null}},
    {"offset": {"line": 221, "column": 0}, "map": {"version":3,"sources":["file:///home/alpha/code/%40redbtn/webapp/src/app/api/v1/logs/stats/route.ts"],"sourcesContent":["/**\n * API endpoint to get logging system stats\n * GET /api/v1/logs/stats\n * \n * Returns statistics about the logging system\n */\n\nimport { NextRequest, NextResponse } from 'next/server';\nimport { red } from '@/lib/red';\nimport { LogEntry } from '@redbtn/ai';\n\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url);\n    const conversationId = searchParams.get('conversationId');\n    \n    if (conversationId) {\n      // Stats for a specific conversation\n      const logs = await red.logger.getConversationLogs(conversationId);\n      const state = await red.logger.getConversationGenerationState(conversationId);\n      \n      // Count by level\n      const byLevel = logs.reduce((acc: Record<string, number>, log: LogEntry) => {\n        acc[log.level] = (acc[log.level] || 0) + 1;\n        return acc;\n      }, {} as Record<string, number>);\n      \n      // Count by category\n      const byCategory = logs.reduce((acc: Record<string, number>, log: LogEntry) => {\n        acc[log.category] = (acc[log.category] || 0) + 1;\n        return acc;\n      }, {} as Record<string, number>);\n      \n      return NextResponse.json({\n        conversationId,\n        totalLogs: logs.length,\n        generationCount: state?.generationCount || 0,\n        isGenerating: !!state?.currentGenerationId,\n        byLevel,\n        byCategory,\n      });\n    }\n    \n    // Global stats would require scanning all Redis keys\n    // For now, return minimal info\n    return NextResponse.json({\n      status: 'operational',\n      message: 'Logging system is running. Provide conversationId for detailed stats.',\n    });\n  } catch (error) {\n    console.error('[API] Error fetching logging stats:', error);\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;AAED;AACA;;;;;;;AAGO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;QAC5C,MAAM,iBAAiB,aAAa,GAAG,CAAC;QAExC,IAAI,gBAAgB;YAClB,oCAAoC;YACpC,MAAM,OAAO,MAAM,0HAAG,CAAC,MAAM,CAAC,mBAAmB,CAAC;YAClD,MAAM,QAAQ,MAAM,0HAAG,CAAC,MAAM,CAAC,8BAA8B,CAAC;YAE9D,iBAAiB;YACjB,MAAM,UAAU,KAAK,MAAM,CAAC,CAAC,KAA6B;gBACxD,GAAG,CAAC,IAAI,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,KAAK,CAAC,IAAI,CAAC,IAAI;gBACzC,OAAO;YACT,GAAG,CAAC;YAEJ,oBAAoB;YACpB,MAAM,aAAa,KAAK,MAAM,CAAC,CAAC,KAA6B;gBAC3D,GAAG,CAAC,IAAI,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,QAAQ,CAAC,IAAI,CAAC,IAAI;gBAC/C,OAAO;YACT,GAAG,CAAC;YAEJ,OAAO,gJAAY,CAAC,IAAI,CAAC;gBACvB;gBACA,WAAW,KAAK,MAAM;gBACtB,iBAAiB,OAAO,mBAAmB;gBAC3C,cAAc,CAAC,CAAC,OAAO;gBACvB;gBACA;YACF;QACF;QAEA,qDAAqD;QACrD,+BAA+B;QAC/B,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,QAAQ;YACR,SAAS;QACX;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,uCAAuC;QACrD,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAwB,GACjC;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}