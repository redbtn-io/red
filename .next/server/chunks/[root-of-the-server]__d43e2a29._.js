module.exports = [
"[project]/.next-internal/server/app/api/v1/messages/[messageId]/stream/route/actions.js [app-rsc] (server actions loader, ecmascript)", ((__turbopack_context__, module, exports) => {

}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/fs [external] (fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}),
"[externals]/path [external] (path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}),
"[externals]/os [external] (os, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[externals]/events [external] (events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}),
"[externals]/assert [external] (assert, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/tty [external] (tty, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tty", () => require("tty"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/dns [external] (dns, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("dns", () => require("dns"));

module.exports = mod;
}),
"[externals]/net [external] (net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}),
"[externals]/tls [external] (tls, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}),
"[externals]/buffer [external] (buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}),
"[externals]/string_decoder [external] (string_decoder, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("string_decoder", () => require("string_decoder"));

module.exports = mod;
}),
"[externals]/mongodb [external] (mongodb, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("mongodb", () => require("mongodb"));

module.exports = mod;
}),
"[externals]/node:crypto [external] (node:crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:crypto", () => require("node:crypto"));

module.exports = mod;
}),
"[externals]/node:async_hooks [external] (node:async_hooks, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:async_hooks", () => require("node:async_hooks"));

module.exports = mod;
}),
"[externals]/child_process [external] (child_process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("child_process", () => require("child_process"));

module.exports = mod;
}),
"[project]/src/lib/red.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

return __turbopack_context__.a(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {

/**
 * Red AI instance initialization for Next.js API routes
 */ __turbopack_context__.s([
    "BEARER_TOKEN",
    ()=>BEARER_TOKEN,
    "getRed",
    ()=>getRed,
    "getRedSync",
    ()=>getRedSync,
    "red",
    ()=>red
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$redbtn$2f$ai$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@redbtn/ai/dist/index.js [app-route] (ecmascript)");
;
const config = {
    redisUrl: process.env.REDIS_URL || "redis://localhost:6379",
    vectorDbUrl: process.env.VECTOR_DB_URL || "http://localhost:8200",
    databaseUrl: process.env.DATABASE_URL || "http://localhost:5432",
    defaultLlmUrl: process.env.LLM_URL || "http://localhost:11434"
};
let redInstance = null;
async function getRed() {
    if (!redInstance) {
        redInstance = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$redbtn$2f$ai$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Red"](config);
        await redInstance.load('webapp-api');
        console.log('âœ… Red AI initialized successfully');
    }
    return redInstance;
}
function getRedSync() {
    if (!redInstance) {
        throw new Error('Red instance not initialized. Call getRed() first.');
    }
    return redInstance;
}
// Initialize immediately for synchronous access in API routes
// This allows `import { red }` to work
let initPromise = null;
if (!initPromise) {
    initPromise = getRed();
}
const red = await initPromise;
const BEARER_TOKEN = process.env.BEARER_TOKEN || `red_ai_sk_${Date.now()}`;
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, true);}),
"[project]/src/app/api/v1/messages/[messageId]/stream/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

return __turbopack_context__.a(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {

__turbopack_context__.s([
    "GET",
    ()=>GET
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$red$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/red.ts [app-route] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$red$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__
]);
[__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$red$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__;
;
async function GET(request, { params }) {
    const { messageId } = await params;
    console.log(`[Stream] Client connecting to message: ${messageId}`);
    try {
        const red = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$red$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getRed"])();
        const messageQueue = red.messageQueue;
        // Create SSE stream with proper cleanup
        const encoder = new TextEncoder();
        let messageStream = null;
        let isCancelled = false;
        let controllerClosed = false;
        const safeEnqueue = (data)=>{
            if (isCancelled || controllerClosed) return false;
            try {
                controller.enqueue(data);
                return true;
            } catch  {
                // Controller closed during enqueue
                controllerClosed = true;
                return false;
            }
        };
        const safeClose = ()=>{
            if (controllerClosed) return;
            try {
                controller.close();
                controllerClosed = true;
            } catch  {
                // Already closed
                controllerClosed = true;
            }
        };
        let controller;
        const stream = new ReadableStream({
            async start (ctrl) {
                controller = ctrl;
                try {
                    // Send initial comment to establish connection and prevent buffering
                    safeEnqueue(encoder.encode(`: connected\n\n`));
                    console.log(`[Stream] Connection established for ${messageId}`);
                    // Mark stream as ready FIRST, before subscribing
                    // This signals to the completions endpoint that we're connected
                    await messageQueue.markStreamReady(messageId);
                    console.log(`[Stream] Marked stream ready for ${messageId}`);
                    // Send another keepalive to ensure connection is fully open
                    safeEnqueue(encoder.encode(`: ready\n\n`));
                    // Subscribe to message updates
                    messageStream = messageQueue.subscribeToMessage(messageId);
                    for await (const event of messageStream){
                        // Check if stream was cancelled
                        if (isCancelled) {
                            console.log('[Stream] Stream cancelled, stopping iteration');
                            break;
                        }
                        if (event.type === 'init' && event.existingContent) {
                            // Send existing content in chunks for smooth display
                            console.log(`[Stream] Sending ${event.existingContent.length} chars of existing content`);
                            const chunks = event.existingContent.match(/.{1,50}/g) || [];
                            for (const chunk of chunks){
                                if (isCancelled) break;
                                const data = {
                                    type: 'content',
                                    content: chunk
                                };
                                if (!safeEnqueue(encoder.encode(`data: ${JSON.stringify(data)}\n\n`))) {
                                    break;
                                }
                            }
                        } else if (event.type === 'chunk') {
                            // Stream new chunk
                            const data = {
                                type: 'content',
                                content: event.content
                            };
                            if (!safeEnqueue(encoder.encode(`data: ${JSON.stringify(data)}\n\n`))) {
                                break;
                            }
                        } else if (event.type === 'status') {
                            // Send status update (processing, thinking, routing, etc.)
                            console.log('[SSE] Forwarding status:', event.action);
                            const data = {
                                type: 'status',
                                action: event.action,
                                description: event.description
                            };
                            safeEnqueue(encoder.encode(`data: ${JSON.stringify(data)}\n\n`));
                            // Force flush with comment
                            safeEnqueue(encoder.encode(`: flush\n\n`));
                        } else if (event.type === 'thinking_chunk') {
                            // Stream thinking character-by-character
                            const data = {
                                type: 'thinking_chunk',
                                content: event.content
                            };
                            if (!safeEnqueue(encoder.encode(`data: ${JSON.stringify(data)}\n\n`))) {
                                break;
                            }
                        } else if (event.type === 'thinking') {
                            // Stream thinking/reasoning content (legacy full block)
                            const data = {
                                type: 'thinking',
                                content: event.content
                            };
                            if (!safeEnqueue(encoder.encode(`data: ${JSON.stringify(data)}\n\n`))) {
                                break;
                            }
                        } else if (event.type === 'tool_status') {
                            // Send tool status indicator
                            const toolEvent = event;
                            const data = {
                                type: 'tool_status',
                                status: toolEvent.status,
                                action: toolEvent.action
                            };
                            safeEnqueue(encoder.encode(`data: ${JSON.stringify(data)}\n\n`));
                            // Force flush with comment
                            safeEnqueue(encoder.encode(`: flush\n\n`));
                        } else if (event.type === 'complete') {
                            // Send completion event
                            const data = {
                                type: 'complete',
                                metadata: event.metadata
                            };
                            safeEnqueue(encoder.encode(`data: ${JSON.stringify(data)}\n\n`));
                            safeEnqueue(encoder.encode('data: [DONE]\n\n'));
                            break;
                        } else if (event.type === 'error') {
                            // Send error event
                            const data = {
                                type: 'error',
                                error: event.error
                            };
                            safeEnqueue(encoder.encode(`data: ${JSON.stringify(data)}\n\n`));
                            break;
                        }
                    }
                    safeClose();
                } catch (error) {
                    console.error('[Stream] Error:', error);
                    const data = {
                        type: 'error',
                        error: error instanceof Error ? error.message : String(error)
                    };
                    safeEnqueue(encoder.encode(`data: ${JSON.stringify(data)}\n\n`));
                    safeClose();
                }
            },
            async cancel () {
                console.log(`[Stream] Client disconnected from message: ${messageId}`);
                isCancelled = true;
                // Clean up the async generator/Redis subscription
                if (messageStream && typeof messageStream.return === 'function') {
                    try {
                        await messageStream.return();
                    } catch  {
                    // Ignore cleanup errors
                    }
                }
            }
        });
        return new Response(stream, {
            headers: {
                'Content-Type': 'text/event-stream',
                'Cache-Control': 'no-cache, no-transform',
                'Connection': 'keep-alive',
                'X-Accel-Buffering': 'no'
            }
        });
    } catch (error) {
        console.error('[Stream] Failed to create stream:', error);
        return new Response(JSON.stringify({
            error: {
                message: error instanceof Error ? error.message : 'Failed to create stream',
                type: 'stream_error'
            }
        }), {
            status: 500,
            headers: {
                'Content-Type': 'application/json'
            }
        });
    }
}
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__d43e2a29._.js.map