module.exports = [
"[project]/.next-internal/server/app/api/v1/chat/completions/route/actions.js [app-rsc] (server actions loader, ecmascript)", ((__turbopack_context__, module, exports) => {

}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/action-async-storage.external.js [external] (next/dist/server/app-render/action-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/action-async-storage.external.js", () => require("next/dist/server/app-render/action-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/fs [external] (fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}),
"[externals]/path [external] (path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}),
"[externals]/os [external] (os, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[externals]/events [external] (events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}),
"[externals]/assert [external] (assert, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/tty [external] (tty, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tty", () => require("tty"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/dns [external] (dns, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("dns", () => require("dns"));

module.exports = mod;
}),
"[externals]/net [external] (net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}),
"[externals]/tls [external] (tls, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}),
"[externals]/buffer [external] (buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}),
"[externals]/string_decoder [external] (string_decoder, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("string_decoder", () => require("string_decoder"));

module.exports = mod;
}),
"[externals]/mongodb [external] (mongodb, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("mongodb", () => require("mongodb"));

module.exports = mod;
}),
"[externals]/node:crypto [external] (node:crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:crypto", () => require("node:crypto"));

module.exports = mod;
}),
"[externals]/node:async_hooks [external] (node:async_hooks, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:async_hooks", () => require("node:async_hooks"));

module.exports = mod;
}),
"[externals]/child_process [external] (child_process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("child_process", () => require("child_process"));

module.exports = mod;
}),
"[project]/src/lib/red.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

return __turbopack_context__.a(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {

/**
 * Red AI instance initialization for Next.js API routes
 */ __turbopack_context__.s([
    "BEARER_TOKEN",
    ()=>BEARER_TOKEN,
    "getRed",
    ()=>getRed,
    "getRedSync",
    ()=>getRedSync,
    "red",
    ()=>red
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$redbtn$2f$ai$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@redbtn/ai/dist/index.js [app-route] (ecmascript)");
;
const config = {
    redisUrl: process.env.REDIS_URL || "redis://localhost:6379",
    vectorDbUrl: process.env.VECTOR_DB_URL || "http://localhost:8200",
    databaseUrl: process.env.DATABASE_URL || "http://localhost:5432",
    defaultLlmUrl: process.env.LLM_URL || "http://localhost:11434"
};
let redInstance = null;
async function getRed() {
    if (!redInstance) {
        redInstance = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$redbtn$2f$ai$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Red"](config);
        await redInstance.load('webapp-api');
        console.log('âœ… Red AI initialized successfully');
    }
    return redInstance;
}
function getRedSync() {
    if (!redInstance) {
        throw new Error('Red instance not initialized. Call getRed() first.');
    }
    return redInstance;
}
// Initialize immediately for synchronous access in API routes
// This allows `import { red }` to work
let initPromise = null;
if (!initPromise) {
    initPromise = getRed();
}
const red = await initPromise;
const BEARER_TOKEN = process.env.BEARER_TOKEN || `red_ai_sk_${Date.now()}`;
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, true);}),
"[project]/src/lib/api-helpers.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Helper functions for API routes
 */ __turbopack_context__.s([
    "extractUserMessage",
    ()=>extractUserMessage,
    "generateCompletionId",
    ()=>generateCompletionId,
    "generateStableConversationId",
    ()=>generateStableConversationId,
    "getConversationIdFromBody",
    ()=>getConversationIdFromBody,
    "getModelDetails",
    ()=>getModelDetails,
    "getModelsList",
    ()=>getModelsList
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/crypto [external] (crypto, cjs)");
;
function generateCompletionId() {
    return `chatcmpl-${Date.now()}-${Math.random().toString(36).substring(7)}`;
}
function extractUserMessage(messages) {
    const lastUserMessage = [
        ...messages
    ].reverse().find((m)=>m.role === 'user');
    return lastUserMessage?.content || '';
}
function getConversationIdFromBody(body) {
    const possibleFields = [
        'chat_id',
        'chatId',
        'conversation_id',
        'conversationId',
        'session_id',
        'sessionId',
        'thread_id',
        'threadId'
    ];
    for (const field of possibleFields){
        if (body[field]) {
            return body[field];
        }
    }
    return undefined;
}
function generateStableConversationId(messages) {
    const firstUserMessage = messages.find((m)=>m.role === 'user');
    if (!firstUserMessage) {
        return `conv_${__TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["default"].randomBytes(8).toString('hex')}`;
    }
    const hash = __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["default"].createHash('sha256').update(firstUserMessage.content).digest('hex').substring(0, 16);
    return `conv_${hash}`;
}
function getModelsList() {
    return {
        object: 'list',
        data: [
            {
                id: 'Red',
                object: 'model',
                created: Math.floor(Date.now() / 1000),
                owned_by: 'redbtn',
                permission: [],
                root: 'Red',
                parent: null
            }
        ]
    };
}
function getModelDetails(modelId) {
    if (modelId === 'Red' || modelId === 'red') {
        return {
            id: 'Red',
            object: 'model',
            created: Math.floor(Date.now() / 1000),
            owned_by: 'redbtn',
            permission: [],
            root: 'Red',
            parent: null
        };
    }
    return null;
}
}),
"[project]/src/app/api/v1/chat/completions/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

return __turbopack_context__.a(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {

__turbopack_context__.s([
    "POST",
    ()=>POST
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$red$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/red.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$api$2d$helpers$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/api-helpers.ts [app-route] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$red$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__
]);
[__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$red$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__;
;
;
;
async function POST(request) {
    try {
        const body = await request.json();
        if (!body.messages || body.messages.length === 0) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: {
                    message: 'messages is required and must not be empty',
                    type: 'invalid_request_error',
                    code: 'invalid_messages'
                }
            }, {
                status: 400
            });
        }
        const completionId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$api$2d$helpers$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["generateCompletionId"])();
        const created = Math.floor(Date.now() / 1000);
        const modelName = body.model || 'Red';
        const userMessage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$api$2d$helpers$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["extractUserMessage"])(body.messages);
        const conversationId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$api$2d$helpers$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getConversationIdFromBody"])(body) || request.headers.get('x-conversation-id') || (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$api$2d$helpers$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["generateStableConversationId"])(body.messages);
        console.log(`ðŸ”— Using conversation ID: ${conversationId}`);
        const red = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$red$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getRed"])();
        const messageId = body.messageId || `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        if (body.stream) {
            await red.messageQueue.startGeneration(conversationId, messageId);
            const encoder = new TextEncoder();
            let subscriptionReady = false;
            const subscriptionReadyPromise = new Promise((resolve)=>{
                const checkReady = ()=>{
                    if (subscriptionReady) {
                        resolve();
                    } else {
                        setTimeout(checkReady, 10);
                    }
                };
                checkReady();
            });
            const generationPromise = (async ()=>{
                try {
                    console.log('[Completions] Waiting for subscription to be ready...');
                    await subscriptionReadyPromise;
                    console.log('[Completions] Subscription ready, starting generation for', messageId);
                    const responseStream = await red.respond({
                        message: userMessage
                    }, {
                        source: {
                            application: 'redChat'
                        },
                        stream: true,
                        conversationId,
                        messageId
                    });
                    for await (const chunk of responseStream){
                        if (typeof chunk === 'object' && chunk._metadata) continue;
                        if (typeof chunk === 'object' && chunk._status) {
                            await red.messageQueue.publishStatus(messageId, {
                                action: chunk.action,
                                description: chunk.description
                            });
                            continue;
                        }
                        if (typeof chunk === 'object' && chunk._thinkingChunk) {
                            await red.messageQueue.publishThinkingChunk(messageId, chunk.content);
                            continue;
                        }
                        if (typeof chunk === 'object' && chunk._toolStatus) {
                            await red.messageQueue.publishToolStatus(messageId, {
                                status: chunk.status,
                                action: chunk.action
                            });
                            continue;
                        }
                        if (typeof chunk === 'string') {
                            await red.messageQueue.appendContent(messageId, chunk);
                        } else {
                            const metadata = {
                                model: chunk.response_metadata?.model,
                                tokens: chunk.usage_metadata ? {
                                    input: chunk.usage_metadata.input_tokens,
                                    output: chunk.usage_metadata.output_tokens,
                                    total: chunk.usage_metadata.total_tokens
                                } : undefined
                            };
                            await red.messageQueue.completeGeneration(messageId, metadata);
                        }
                    }
                } catch (error) {
                    console.error(`[Completions] Generation failed:`, error);
                    await red.messageQueue.failGeneration(messageId, error instanceof Error ? error.message : String(error));
                }
            })();
            const stream = new ReadableStream({
                async start (controller) {
                    let streamClosed = false;
                    const safeEnqueue = (data)=>{
                        if (streamClosed) {
                            console.log('[Completions] Skipping enqueue - stream already closed');
                            return false;
                        }
                        try {
                            controller.enqueue(data);
                            return true;
                        } catch (error) {
                            if (error instanceof Error && error.message.includes('Controller is already closed')) {
                                console.log('[Completions] Stream closed by client');
                                streamClosed = true;
                                return false;
                            }
                            throw error;
                        }
                    };
                    try {
                        const initEvent = {
                            type: 'init',
                            messageId,
                            conversationId
                        };
                        console.log('[Completions] Sending init event and subscribing to Redis');
                        if (!safeEnqueue(encoder.encode(`data: ${JSON.stringify(initEvent)}\n\n`))) {
                            return;
                        }
                        console.log('[Completions] Subscribing to message queue...');
                        const messageStream = red.messageQueue.subscribeToMessage(messageId);
                        console.log('[Completions] Subscription established, signaling generation to start');
                        subscriptionReady = true;
                        for await (const event of messageStream){
                            if (streamClosed) {
                                console.log('[Completions] Stream closed, stopping subscription');
                                break;
                            }
                            console.log('[Completions] Received event from Redis:', event.type);
                            if (event.type === 'init' && event.existingContent) {
                                const chunks = event.existingContent.match(/.{1,50}/g) || [];
                                for (const chunk of chunks){
                                    if (!safeEnqueue(encoder.encode(`data: ${JSON.stringify({
                                        type: 'content',
                                        content: chunk
                                    })}\n\n`))) break;
                                }
                            } else if (event.type === 'chunk') {
                                if (!safeEnqueue(encoder.encode(`data: ${JSON.stringify({
                                    type: 'content',
                                    content: event.content
                                })}\n\n`))) break;
                            } else if (event.type === 'status') {
                                console.log('[Completions] Forwarding status:', event.action);
                                if (!safeEnqueue(encoder.encode(`data: ${JSON.stringify({
                                    type: 'status',
                                    action: event.action,
                                    description: event.description
                                })}\n\n`))) break;
                            } else if (event.type === 'thinking_chunk') {
                                if (!safeEnqueue(encoder.encode(`data: ${JSON.stringify({
                                    type: 'thinking_chunk',
                                    content: event.content
                                })}\n\n`))) break;
                            } else if (event.type === 'thinking') {
                                if (!safeEnqueue(encoder.encode(`data: ${JSON.stringify({
                                    type: 'thinking',
                                    content: event.content
                                })}\n\n`))) break;
                            } else if (event.type === 'tool_status') {
                                console.log('[Completions] Forwarding tool_status:', event.action);
                                if (!safeEnqueue(encoder.encode(`data: ${JSON.stringify({
                                    type: 'tool_status',
                                    status: event.status,
                                    action: event.action
                                })}\n\n`))) break;
                            } else if (event.type === 'complete') {
                                safeEnqueue(encoder.encode(`data: ${JSON.stringify({
                                    type: 'complete',
                                    metadata: event.metadata
                                })}\n\n`));
                                break;
                            } else if (event.type === 'error') {
                                safeEnqueue(encoder.encode(`data: ${JSON.stringify({
                                    type: 'error',
                                    error: event.error
                                })}\n\n`));
                                break;
                            }
                        }
                        safeEnqueue(encoder.encode('data: [DONE]\n\n'));
                        if (!streamClosed) controller.close();
                    } catch (error) {
                        console.error(`[Completions] Stream error:`, error);
                        if (!streamClosed) {
                            safeEnqueue(encoder.encode(`data: ${JSON.stringify({
                                type: 'error',
                                error: error instanceof Error ? error.message : String(error)
                            })}\n\n`));
                            controller.close();
                        }
                    }
                }
            });
            return new Response(stream, {
                headers: {
                    'Content-Type': 'text/event-stream',
                    'Cache-Control': 'no-cache, no-transform',
                    'Connection': 'keep-alive',
                    'X-Accel-Buffering': 'no'
                }
            });
        }
        const response = await red.respond({
            message: userMessage
        }, {
            source: {
                application: 'redChat'
            },
            conversationId
        });
        const completion = {
            id: completionId,
            object: 'chat.completion',
            created,
            model: modelName,
            conversationId: response.conversationId || conversationId,
            choices: [
                {
                    index: 0,
                    message: {
                        role: 'assistant',
                        content: typeof response.content === 'string' ? response.content : JSON.stringify(response.content)
                    },
                    finish_reason: 'stop'
                }
            ],
            usage: {
                prompt_tokens: 0,
                completion_tokens: 0,
                total_tokens: 0
            }
        };
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json(completion);
    } catch (error) {
        console.error('Completion error:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: {
                message: error.message || 'Internal server error',
                type: 'internal_error'
            }
        }, {
            status: 500
        });
    }
}
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__f21ad798._.js.map