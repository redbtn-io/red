# redbtn API Documentation

**Version:** 2.0  
**Base URL:** `/api`

Complete documentation for the redbtn REST API. This API provides AI chat completions, conversation management, nodes, neurons, graphs, authentication, OAuth, and logging capabilities.

---

## üìã Table of Contents

1. [Authentication](#authentication)
2. [OAuth 2.0](#oauth-20)
3. [Chat & Completions](#chat--completions)
4. [Conversations](#conversations)
5. [Messages](#messages)
6. [Nodes](#nodes)
7. [Neurons](#neurons)
8. [Graphs](#graphs)
9. [Knowledge Libraries](#knowledge-libraries)
10. [User Preferences](#user-preferences)
11. [Models](#models)
12. [Cleanup](#cleanup)
13. [Logging & Monitoring](#logging--monitoring)
14. [Rate Limiting](#rate-limiting)
15. [Error Handling](#error-handling)
16. [Streaming Protocol](#streaming-protocol)

## üóÇÔ∏è Directory Overview & Local Tooling

The API surface lives inside the Next.js app directory. Key folders:

- `src/app/api/auth/*` ‚Äì magic-link authentication endpoints (request code, check session, logout)
- `src/app/api/oauth/*` ‚Äì OAuth 2.0 authorization server endpoints
- `src/app/api/v1/chat/completions` ‚Äì OpenAI-compatible entry point that decouples HTTP from generation
- `src/app/api/v1/messages/[messageId]/*` ‚Äì reconnectable SSE stream endpoints
- `src/app/api/v1/conversations/*` ‚Äì CRUD + telemetry for stored conversations
- `src/app/api/v1/nodes/*` ‚Äì node configuration CRUD, fork, abandon, restore
- `src/app/api/v1/neurons/*` ‚Äì neuron (LLM config) CRUD, fork, abandon, restore
- `src/app/api/v1/graphs/*` ‚Äì graph workflow CRUD and fork
- `src/app/api/v1/user/preferences/*` ‚Äì user preferences and archive management
- `src/app/api/v1/cleanup/*` ‚Äì admin cleanup jobs for abandoned resources
- `src/app/api/v1/models/*` ‚Äì available model listing
- `src/app/api/v1/logs/*` and `generations/*` ‚Äì diagnostics, log tailing, and generation metadata
- `src/app/api/oauth/*` ‚Äì OAuth 2.0 authorization server
- `src/app/api/health` ‚Äì lightweight readiness probe for load balancers

Because this workspace also contains the `ai/` package, we keep shared automation at the root under `scripts/`. In particular, `scripts/pre-commit-cleanup.sh` moves stray markdown documents into `/explanations` and removes nested `explanations/` or `scripts/` folders from the Next.js project. Run it manually before submitting docs-heavy changes:

```bash
./scripts/pre-commit-cleanup.sh ./webapp
```

To automate the process, configure Git once inside `webapp/`:

```bash
git config core.hooksPath .githooks
```

The hook simply calls the shared script with `./webapp` so local commits and CI both enforce the documentation policy.

---

## üîê Authentication

All API endpoints (except auth endpoints) require authentication via JWT token stored in an httpOnly cookie named `auth_token`.

### Request Sign In Link

**`POST /api/auth/request-code`**

Request a sign-in link to be sent via email. Uses session-based authentication with polling.

**Rate Limit:** 10 requests per 300 seconds (AUTH tier)

**Request Body:**
```json
{
  "email": "user@example.com",
  "sessionId": "session_1234567890_abc123"
}
```

**Success Response (200):**
```json
{
  "success": true,
  "message": "Sign in link sent to your email",
  "sessionId": "session_1234567890_abc123"
}
```

**Error Responses:**
- `400` - Missing or invalid email/sessionId
- `429` - Rate limit exceeded
- `500` - Failed to send sign in link

**Notes:**
- `sessionId` should be a unique identifier generated by the client (format: `session_{timestamp}_{random}`)
- Sign-in link expires in 10 minutes
- Old codes for the same email are automatically invalidated

---

### Check Session Status

**`POST /api/auth/check-session`**

Poll this endpoint to check if the user has clicked the sign-in link. Frontend should poll every 2 seconds.

**Request Body:**
```json
{
  "sessionId": "session_1234567890_abc123"
}
```

**Success Response (200) - Authenticated:**
```json
{
  "authenticated": true,
  "isNewUser": false,
  "profileComplete": true,
  "user": {
    "id": "507f1f77bcf86cd799439011",
    "email": "user@example.com",
    "name": "John Doe",
    "profileComplete": true,
    "accountLevel": "USER"
  }
}
```

**Response (200) - Not Yet Authenticated:**
```json
{
  "authenticated": false,
  "message": "Waiting for magic link verification"
}
```

**Response (200) - Expired:**
```json
{
  "authenticated": false,
  "expired": true,
  "message": "Session expired"
}
```

**Notes:**
- Sets `auth_token` httpOnly cookie on successful authentication
- Session is deleted after successful authentication
- Cookie expires in 7 days

---

### Get Current User

**`GET /api/auth/me`**

Get the currently authenticated user's information.

**Authentication:** Required

**Success Response (200):**
```json
{
  "user": {
    "id": "507f1f77bcf86cd799439011",
    "email": "user@example.com",
    "name": "John Doe",
    "dateOfBirth": "1990-01-01",
    "profileComplete": true,
    "accountLevel": "USER",
    "createdAt": "2025-10-01T12:00:00.000Z"
  }
}
```

**Error Responses:**
- `401` - Unauthorized (no valid token)
- `404` - User not found
- `500` - Server error

---

### Complete User Profile

**`POST /api/auth/complete-profile`**

Complete user profile after initial sign-in (required for new users).

**Authentication:** Required

**Request Body:**
```json
{
  "name": "John Doe",
  "dateOfBirth": "1990-01-01"
}
```

**Success Response (200):**
```json
{
  "success": true,
  "user": {
    "id": "507f1f77bcf86cd799439011",
    "email": "user@example.com",
    "name": "John Doe",
    "dateOfBirth": "1990-01-01",
    "profileComplete": true,
    "accountLevel": "USER"
  }
}
```

**Error Responses:**
- `400` - Missing required fields
- `401` - Unauthorized
- `500` - Server error

---

### Logout

**`POST /api/auth/logout`**

Logout the current user by clearing the auth token cookie.

**Authentication:** Required

**Success Response (200):**
```json
{
  "success": true,
  "message": "Logged out successfully"
}
```

---

## üí¨ Chat & Completions

### Create Chat Completion

**`POST /api/v1/chat/completions`**

Create a chat completion with optional streaming. This is the main endpoint for AI interactions.

**Rate Limit:** 30 requests per 60 seconds (CHAT tier)

**Request Body:**
```json
{
  "model": "Red",
  "messages": [
    {
      "role": "user",
      "content": "Hello, how are you?"
    }
  ],
  "stream": true,
  "conversationId": "conv_1234567890_abc123",
  "messageId": "msg_1234567890_xyz789"
}
```

**Fields:**
- `model` (string, optional): Model name, defaults to "Red"
- `messages` (array, required): Array of message objects with `role` and `content`
- `stream` (boolean, optional): Enable streaming mode, defaults to false
- `conversationId` (string, optional): Conversation ID for context, auto-generated if omitted
- `messageId` (string, optional): Message ID for tracking, auto-generated if omitted

---

#### Non-Streaming Response (stream: false)

**Success Response (200):**
```json
{
  "id": "chatcmpl_1234567890",
  "object": "chat.completion",
  "created": 1698765432,
  "model": "Red",
  "conversationId": "conv_1234567890_abc123",
  "choices": [
    {
      "index": 0,
      "message": {
        "role": "assistant",
        "content": "Hello! I'm doing well, thank you for asking. How can I help you today?"
      },
      "finish_reason": "stop"
    }
  ],
  "usage": {
    "prompt_tokens": 15,
    "completion_tokens": 20,
    "total_tokens": 35
  }
}
```

---

#### Streaming Response (stream: true)

**Response Headers:**
```
Content-Type: text/event-stream
Cache-Control: no-cache, no-transform
Connection: keep-alive
X-Accel-Buffering: no
```

**Stream Events:**

Each event is formatted as Server-Sent Events (SSE):
```
data: {JSON}\n\n
```

**1. Init Event** (first event):
```json
{
  "type": "init",
  "messageId": "msg_1234567890_xyz789",
  "conversationId": "conv_1234567890_abc123"
}
```

**2. Chunk Events** (text content):
```json
{
  "type": "chunk",
  "content": "Hello",
  "thinking": false
}
```

**Note:** Chunks with `thinking: true` indicate the content is AI reasoning/thinking rather than final response. Thinking content is sent as regular chunks with this flag, not as separate events.

**3. Status Events** (AI is performing actions):
```json
{
  "type": "status",
  "action": "searching",
  "description": "Searching the web..."
}
```

**4. Tool Event** (tool execution details):
```json
{
  "type": "tool_event",
  "event": {
    "type": "tool_start",
    "toolId": "search_123",
    "toolType": "search",
    "toolName": "Web Search",
    "timestamp": 1698765432000,
    "metadata": {
      "query": "latest AI news"
    }
  }
}
```

Tool event types:
- `tool_start` - Tool execution begins
- `tool_progress` - Progress update during tool execution
- `tool_complete` - Tool execution completed
- `tool_error` - Tool execution failed

**5. Complete Event** (final event):
```json
{
  "type": "complete",
  "metadata": {
    "model": "Red",
    "tokens": {
      "input": 15,
      "output": 42,
      "total": 57
    }
  }
}
```

**6. Error Event:**
```json
{
  "type": "error",
  "error": "Generation failed: timeout"
}
```

**7. Done Event** (stream termination):
```
data: [DONE]\n\n
```

**Error Responses:**
- `400` - Invalid request (missing messages)
- `429` - Rate limit exceeded
- `500` - Internal server error

---

## üìù Conversations

### List Conversations

**`GET /api/v1/conversations`**

Get all conversations for the authenticated user.

**Authentication:** Required  
**Rate Limit:** 60 requests per 60 seconds (STANDARD tier)

**Query Parameters:**
- `limit` (number, optional): Number of conversations to return, default 50
- `offset` (number, optional): Pagination offset, default 0

**Success Response (200):**
```json
{
  "conversations": [
    {
      "id": "conv_1234567890_abc123",
      "title": "AI Research Discussion",
      "lastMessageAt": "2025-10-21T15:30:00.000Z",
      "messageCount": 15,
      "isArchived": false,
      "createdAt": "2025-10-21T10:00:00.000Z",
      "updatedAt": "2025-10-21T15:30:00.000Z"
    }
  ],
  "total": 1,
  "limit": 50,
  "offset": 0
}
```

**Error Responses:**
- `401` - Unauthorized
- `500` - Failed to fetch conversations

---

### Create Conversation

**`POST /api/v1/conversations`**

Create a new conversation. Returns a conversation ID that can be used for future messages.

**Authentication:** Required  
**Rate Limit:** 60 requests per 60 seconds (STANDARD tier)

**Request Body:**
```json
{
  "title": "New Chat Session"
}
```

**Success Response (200):**
```json
{
  "conversation": {
    "id": "conv_1698765432_xyz789",
    "title": "New Chat Session",
    "messages": [],
    "lastMessageAt": "2025-10-21T15:45:00.000Z",
    "messageCount": 0,
    "isArchived": false,
    "createdAt": "2025-10-21T15:45:00.000Z",
    "updatedAt": "2025-10-21T15:45:00.000Z"
  }
}
```

**Note:** The actual conversation is created in the database when the first message is sent.

---

### Get Conversation

**`GET /api/v1/conversations/[id]`**

Get a specific conversation with all messages and thoughts.

**Authentication:** Required  
**Rate Limit:** 60 requests per 60 seconds (STANDARD tier)

**Success Response (200):**
```json
{
  "conversation": {
    "id": "conv_1234567890_abc123",
    "title": "AI Research Discussion",
    "messages": [
      {
        "id": "msg_1234567890_aaa111",
        "role": "user",
        "content": "Tell me about AI",
        "timestamp": "2025-10-21T15:00:00.000Z",
        "metadata": {},
        "toolExecutions": []
      },
      {
        "id": "msg_1234567890_bbb222",
        "role": "assistant",
        "content": "AI, or Artificial Intelligence, is...",
        "timestamp": "2025-10-21T15:00:05.000Z",
        "metadata": {},
        "toolExecutions": [
          {
            "toolId": "search_123",
            "toolType": "search",
            "toolName": "Web Search",
            "status": "completed",
            "startTime": 1698765432000,
            "endTime": 1698765434000,
            "steps": [
              {
                "step": "Searching web...",
                "timestamp": 1698765432500
              }
            ],
            "result": "Found 5 relevant articles",
            "metadata": {
              "query": "artificial intelligence overview"
            }
          }
        ]
      }
    ],
    "thoughts": {
      "msg_1234567890_bbb222": "The user is asking for a broad overview. I should provide a comprehensive yet accessible explanation."
    },
    "lastMessageAt": "2025-10-21T15:00:05.000Z",
    "messageCount": 2,
    "isArchived": false,
    "createdAt": "2025-10-21T15:00:00.000Z",
    "updatedAt": "2025-10-21T15:00:05.000Z"
  }
}
```

**Response Fields:**
- `messages` - Array of all messages (thinking tags removed from content)
- `thoughts` - Map of `messageId` ‚Üí thinking content (from `<think>` tags)
- `toolExecutions` - Array of tools used in each message

**Error Responses:**
- `401` - Unauthorized
- `404` - Conversation not found
- `500` - Failed to fetch conversation

---

### Update Conversation

**`PATCH /api/v1/conversations/[id]`**

Update conversation properties (currently only title is supported).

**Authentication:** Required  
**Rate Limit:** 60 requests per 60 seconds (STANDARD tier)

**Request Body:**
```json
{
  "title": "Updated Title"
}
```

**Success Response (200):**
```json
{
  "conversation": {
    "id": "conv_1234567890_abc123",
    "title": "Updated Title",
    "messages": [...],
    "lastMessageAt": "2025-10-21T15:00:05.000Z",
    "messageCount": 2,
    "isArchived": false,
    "createdAt": "2025-10-21T15:00:00.000Z",
    "updatedAt": "2025-10-21T15:45:30.000Z"
  }
}
```

**Error Responses:**
- `401` - Unauthorized
- `404` - Conversation not found
- `500` - Failed to update conversation

---

### Delete Conversation

**`DELETE /api/v1/conversations/[id]`**

Permanently delete a conversation and all its messages.

**Authentication:** Required  
**Rate Limit:** 60 requests per 60 seconds (STANDARD tier)

**Success Response (200):**
```json
{
  "success": true,
  "message": "Conversation deleted"
}
```

**Error Responses:**
- `401` - Unauthorized
- `500` - Failed to delete conversation

---

## üì® Messages

### Reconnect to Message Stream

**`GET /api/v1/messages/[messageId]/reconnect`**

Reconnect to an ongoing message generation stream. Returns current accumulated content and continues streaming.

**Authentication:** Optional (uses same auth as original request)

**Success Response (200):**

Returns SSE stream with same format as `/api/v1/chat/completions` streaming response.

**First Event - Init with Existing Content:**
```json
{
  "type": "init",
  "messageId": "msg_1234567890_xyz789",
  "conversationId": "conv_1234567890_abc123",
  "existingContent": "Hello! I'm doing",
  "existingThinking": "The user greeted me..."
}
```

Then continues with new chunks as they're generated.

**Error Responses:**
- `400` - Missing messageId
- `404` - Message not found or generation not active
- `500` - Failed to reconnect

**Use Case:** Mobile apps can disconnect/reconnect during generation without losing content.

---

### Get Message Stream

**`GET /api/v1/messages/[messageId]/stream`**

Subscribe to a message stream (similar to reconnect but without requiring prior connection).

**Response:** Same SSE format as reconnect endpoint.

---

## üß© Nodes

Nodes are reusable workflow components that can be composed into graphs. They define steps (neuron calls, tool invocations, transforms, conditionals, loops) that execute in sequence.

### List Nodes

**`GET /api/v1/nodes`**

List and search available nodes for the Studio palette.

**Authentication:** Required  
**Rate Limit:** 60 requests per 60 seconds (STANDARD tier)

**Query Parameters:**
- `q` (string): Text search query (searches name, description, tags)
- `tags` (string): Comma-separated list of tags to filter by
- `owner` (string): Filter by owner ("me" for current user, "system" for system nodes)
- `view` (string): Special view ("saved", "favorited", "recent", "archived")
- `sortBy` (string): Sort field (name, createdAt, updatedAt, usageCount, forkCount)
- `sortOrder` (string): Sort direction (asc, desc)
- `limit` (number): Max results (default 50)
- `offset` (number): Pagination offset (default 0)

**Success Response (200):**
```json
{
  "nodes": [
    {
      "nodeId": "planner",
      "name": "Planner",
      "description": "Creates execution plans from user requests",
      "tags": ["core", "planning"],
      "isSystem": true,
      "isImmutable": true,
      "isOwned": false,
      "status": "active",
      "tier": 4,
      "icon": "brain",
      "color": "#8B5CF6",
      "inputs": ["state"],
      "outputs": ["state"],
      "stats": {
        "usageCount": 1250,
        "forkCount": 15
      }
    }
  ],
  "total": 42,
  "tags": ["core", "planning", "search", "chat"]
}
```

---

### Get Node

**`GET /api/v1/nodes/[nodeId]`**

Get details for a specific node including full configuration.

**Authentication:** Required

**Success Response (200):**
```json
{
  "nodeId": "planner",
  "type": "universal",
  "name": "Planner",
  "description": "Creates execution plans",
  "tags": ["core", "planning"],
  "steps": [
    { "stepIndex": 0, "type": "neuron", "configurable": {...} }
  ],
  "fullConfig": [...],
  "parameters": {},
  "metadata": { "icon": "brain", "color": "#8B5CF6" },
  "isSystem": true,
  "isImmutable": true,
  "isOwned": false,
  "status": "active",
  "creatorId": "system"
}
```

---

### Create Node

**`POST /api/v1/nodes`**

Create a new custom node.

**Authentication:** Required

**Request Body:**
```json
{
  "nodeId": "my-custom-node",
  "name": "My Custom Node",
  "description": "Does something useful",
  "tags": ["custom"],
  "steps": [
    {
      "type": "neuron",
      "config": {
        "neuronId": "red-neuron",
        "systemPrompt": "You are a helpful assistant."
      }
    }
  ]
}
```

**Success Response (201):**
```json
{
  "nodeId": "my-custom-node",
  "name": "My Custom Node",
  "created": true
}
```

---

### Update Node

**`PATCH /api/v1/nodes/[nodeId]`**

Update an existing node (must be owned by user and not immutable).

**Authentication:** Required

**Request Body:**
```json
{
  "name": "Updated Name",
  "description": "Updated description",
  "tags": ["custom", "updated"]
}
```

---

### Delete Node

**`DELETE /api/v1/nodes/[nodeId]`**

Delete a node owned by the user.

**Authentication:** Required

---

### Fork Node

**`POST /api/v1/nodes/[nodeId]/fork`**

Create a personal copy (fork) of a node.

**Authentication:** Required

**Request Body:**
```json
{
  "newNodeId": "my-forked-planner",
  "name": "My Planner"
}
```

**Success Response (201):**
```json
{
  "nodeId": "my-forked-planner",
  "parentNodeId": "planner",
  "name": "My Planner",
  "stepsCount": 3,
  "createdAt": "2025-12-20T10:00:00.000Z"
}
```

---

### Abandon Node

**`POST /api/v1/nodes/[nodeId]/abandon`**

Abandon a node you own. The node transfers to the 'abandoned' pseudo-user but remains available to users who forked it. After 90 days (if unused), it will be permanently deleted.

**Authentication:** Required

**Success Response (200):**
```json
{
  "success": true,
  "nodeId": "my-custom-node",
  "abandonedAt": "2025-12-20T10:00:00.000Z",
  "scheduledDeletionAt": "2026-03-20T10:00:00.000Z",
  "forkCount": 5,
  "usageCount": 100,
  "message": "Node abandoned. It has 5 forks and 100 uses. It will remain available to others but removed from your list."
}
```

---

### Restore Node

**`POST /api/v1/nodes/[nodeId]/restore`**

Restore a node you previously abandoned (only the original creator can restore).

**Authentication:** Required

**Success Response (200):**
```json
{
  "success": true,
  "nodeId": "my-custom-node",
  "message": "Node restored successfully"
}
```

---

### Node Preferences

**`GET /api/v1/nodes/preferences`**

Get user's node preferences (saved, favorited, recent nodes).

**Success Response (200):**
```json
{
  "savedNodes": ["planner", "search"],
  "favoritedNodes": ["respond"],
  "recentNodes": ["planner", "router"],
  "tagPreferences": { "pinnedTags": ["core"], "hiddenTags": [] },
  "viewPreferences": {
    "defaultSortBy": "name",
    "defaultSortOrder": "asc",
    "showSystemNodes": true,
    "showPublicNodes": true
  }
}
```

**`POST /api/v1/nodes/preferences`**

Update node preferences (save, favorite, unsave, unfavorite).

**Request Body:**
```json
{
  "action": "save",
  "nodeId": "planner"
}
```

---

## üß† Neurons

Neurons are LLM configurations that define which model, provider, and parameters to use. They are referenced by nodes and can be system defaults or user-customized.

### List Neurons

**`GET /api/v1/neurons`**

List all available neurons for the user based on their tier level.

**Authentication:** Required

**Query Parameters:**
- `role` (string): Filter by role (chat, worker, specialist)
- `provider` (string): Filter by provider (ollama, openai, anthropic, google, custom)

**Success Response (200):**
```json
{
  "neurons": [
    {
      "neuronId": "red-neuron",
      "name": "Red Neuron",
      "description": "Default chat neuron",
      "provider": "ollama",
      "model": "red",
      "role": "chat",
      "tier": 4,
      "isSystem": true,
      "isImmutable": true,
      "isDefault": true
    }
  ]
}
```

---

### Get Neuron

**`GET /api/v1/neurons/[neuronId]`**

Get details for a specific neuron (API keys are NOT exposed).

**Authentication:** Required

---

### Create Neuron

**`POST /api/v1/neurons`**

Create a custom neuron configuration.

**Authentication:** Required

**Request Body:**
```json
{
  "neuronId": "my-gpt4",
  "name": "My GPT-4",
  "provider": "openai",
  "model": "gpt-4-turbo",
  "endpoint": "https://api.openai.com",
  "apiKey": "sk-...",
  "temperature": 0.7,
  "maxTokens": 4096,
  "role": "chat"
}
```

---

### Fork Neuron

**`POST /api/v1/neurons/[neuronId]/fork`**

Create a personal copy (fork) of a neuron.

**Authentication:** Required

**Request Body:**
```json
{
  "newNeuronId": "my-red-neuron",
  "name": "My Red Neuron"
}
```

---

### Abandon Neuron

**`POST /api/v1/neurons/[neuronId]/abandon`**

Abandon a neuron you own. Similar lifecycle to nodes.

**Authentication:** Required

---

### Restore Neuron

**`POST /api/v1/neurons/[neuronId]/restore`**

Restore a neuron you previously abandoned.

**Authentication:** Required

---

## üìä Graphs

Graphs are workflows that connect nodes together with edges and conditions. They define how data flows through a series of processing steps.

### List Graphs

**`GET /api/v1/graphs`**

List available graphs for the user.

**Authentication:** Required

**Query Parameters:**
- `includeSystem` (boolean): Include system graphs (default true)
- `limit` (number): Max results
- `offset` (number): Pagination offset

**Success Response (200):**
```json
{
  "graphs": [
    {
      "graphId": "red-chat",
      "name": "redbtn chat",
      "description": "Default chat graph",
      "tier": 4,
      "isDefault": true,
      "isSystem": true,
      "nodeCount": 5,
      "edgeCount": 4
    }
  ],
  "total": 10
}
```

---

### Get Graph

**`GET /api/v1/graphs/[graphId]`**

Get full details for a specific graph including nodes and edges.

**Authentication:** Required

**Success Response (200):**
```json
{
  "graph": {
    "graphId": "red-chat",
    "name": "redbtn chat",
    "description": "Default chat graph",
    "tier": 4,
    "isDefault": true,
    "isSystem": true,
    "isOwned": false,
    "nodes": [
      { "id": "router", "type": "router", "config": {...} }
    ],
    "edges": [
      { "from": "router", "to": "planner", "condition": "route === 'complex'" }
    ]
  }
}
```

---

### Create Graph

**`POST /api/v1/graphs`**

Create a new custom graph.

**Authentication:** Required

**Request Body:**
```json
{
  "name": "My Custom Graph",
  "description": "A custom workflow",
  "nodes": [
    { "id": "start", "type": "respond", "config": {} }
  ],
  "edges": [],
  "tier": 4
}
```

---

### Update Graph

**`PATCH /api/v1/graphs/[graphId]`**

Update an existing graph (must be owned by user).

**Authentication:** Required

---

### Delete Graph

**`DELETE /api/v1/graphs/[graphId]`**

Delete a graph owned by the user.

**Authentication:** Required

---

### Fork Graph

**`POST /api/v1/graphs/[graphId]/fork`**

Create a personal copy (fork) of a graph.

**Authentication:** Required

**Request Body:**
```json
{
  "newGraphId": "my-red-chat",
  "name": "My redbtn chat"
}
```

---

## ÔøΩ Knowledge Libraries

Knowledge Libraries provide a RAG (Retrieval-Augmented Generation) system for storing, organizing, and searching documents. Libraries support text files (markdown, plain text), PDFs, and images with OCR processing.

### Core Concepts

- **Libraries**: Collections of documents owned by users, with optional sharing and public access
- **Documents**: Individual files stored with metadata, automatically chunked for vector search
- **Vector Search**: Semantic search powered by ChromaDB for finding relevant content
- **OCR Processing**: Automatic text extraction from images and scanned PDFs
- **GridFS Storage**: Large file storage using MongoDB GridFS

### List Libraries

**`GET /api/v1/libraries`**

List all libraries accessible to the authenticated user.

**Authentication:** Required

**Query Parameters:**
| Parameter | Type | Description |
|-----------|------|-------------|
| `includeShared` | boolean | Include libraries shared with user (default: true) |
| `includePublic` | boolean | Include public libraries (default: false) |

**Success Response (200):**
```json
{
  "libraries": [
    {
      "id": "lib_abc123",
      "name": "Project Documentation",
      "description": "Technical docs for the project",
      "ownerId": "user_123",
      "isPublic": false,
      "documentCount": 15,
      "totalSize": 2458624,
      "createdAt": "2025-01-15T10:30:00Z",
      "updatedAt": "2025-01-20T14:22:00Z"
    }
  ]
}
```

---

### Create Library

**`POST /api/v1/libraries`**

Create a new knowledge library.

**Authentication:** Required

**Request Body:**
```json
{
  "name": "My Knowledge Base",
  "description": "Documentation and reference materials",
  "isPublic": false
}
```

**Success Response (201):**
```json
{
  "id": "lib_xyz789",
  "name": "My Knowledge Base",
  "description": "Documentation and reference materials",
  "ownerId": "user_123",
  "isPublic": false,
  "documentCount": 0,
  "createdAt": "2025-01-22T09:00:00Z"
}
```

---

### Get Library Details

**`GET /api/v1/libraries/[libraryId]`**

Get detailed information about a specific library.

**Authentication:** Required (must be owner, shared user, or library must be public)

**Success Response (200):**
```json
{
  "id": "lib_abc123",
  "name": "Project Documentation",
  "description": "Technical docs",
  "ownerId": "user_123",
  "isPublic": false,
  "sharedWith": ["user_456", "user_789"],
  "documentCount": 15,
  "totalSize": 2458624,
  "createdAt": "2025-01-15T10:30:00Z",
  "updatedAt": "2025-01-20T14:22:00Z"
}
```

---

### Update Library

**`PUT /api/v1/libraries/[libraryId]`**

Update library metadata.

**Authentication:** Required (must be owner)

**Request Body:**
```json
{
  "name": "Updated Name",
  "description": "Updated description",
  "isPublic": true
}
```

---

### Delete Library

**`DELETE /api/v1/libraries/[libraryId]`**

Delete a library and all its documents.

**Authentication:** Required (must be owner)

**Success Response (200):**
```json
{
  "success": true,
  "message": "Library deleted successfully"
}
```

---

### Upload Document

**`POST /api/v1/libraries/[libraryId]/upload`**

Upload a document to a library. Supports multipart/form-data.

**Authentication:** Required (must be owner or have write access)

**Supported File Types:**
- Text: `.md`, `.txt`, `.json`, `.yaml`, `.yml`
- Documents: `.pdf`
- Images: `.png`, `.jpg`, `.jpeg`, `.gif`, `.webp` (with OCR)

**Request:** `multipart/form-data`
```
file: <binary>
title: "Optional Document Title"
description: "Optional description"
```

**Success Response (201):**
```json
{
  "id": "doc_abc123",
  "libraryId": "lib_xyz789",
  "title": "API Documentation",
  "filename": "api-docs.md",
  "mimeType": "text/markdown",
  "size": 15234,
  "status": "processing",
  "createdAt": "2025-01-22T09:15:00Z"
}
```

**Notes:**
- Documents are processed asynchronously after upload
- Status transitions: `pending` ‚Üí `processing` ‚Üí `ready` (or `error`)
- Large files are stored in GridFS
- Images trigger OCR processing automatically

---

### List Documents

**`GET /api/v1/libraries/[libraryId]/documents`**

List all documents in a library.

**Authentication:** Required

**Query Parameters:**
| Parameter | Type | Description |
|-----------|------|-------------|
| `status` | string | Filter by status: `pending`, `processing`, `ready`, `error` |
| `limit` | number | Max results (default: 50) |
| `offset` | number | Pagination offset |

**Success Response (200):**
```json
{
  "documents": [
    {
      "id": "doc_abc123",
      "title": "API Documentation",
      "filename": "api-docs.md",
      "mimeType": "text/markdown",
      "size": 15234,
      "status": "ready",
      "chunkCount": 12,
      "createdAt": "2025-01-22T09:15:00Z"
    }
  ],
  "total": 15,
  "limit": 50,
  "offset": 0
}
```

---

### Get Document Content

**`GET /api/v1/libraries/[libraryId]/documents/[documentId]/full`**

Get the full content of a document.

**Authentication:** Required

**Success Response (200):**
```json
{
  "id": "doc_abc123",
  "title": "API Documentation",
  "content": "# API Documentation\n\nThis document describes...",
  "metadata": {
    "wordCount": 1250,
    "language": "en"
  }
}
```

---

### Get Document File

**`GET /api/v1/libraries/[libraryId]/documents/[documentId]/file`**

Download the original file for a document.

**Authentication:** Required

**Response:** Binary file with appropriate Content-Type header

---

### Get Document Chunks

**`GET /api/v1/libraries/[libraryId]/documents/[documentId]/chunks`**

Get the vector chunks for a document.

**Authentication:** Required

**Success Response (200):**
```json
{
  "chunks": [
    {
      "id": "chunk_001",
      "content": "This is the first chunk of text...",
      "index": 0,
      "metadata": {
        "startOffset": 0,
        "endOffset": 512
      }
    }
  ],
  "total": 12
}
```

---

### Reprocess Document

**`POST /api/v1/libraries/[libraryId]/documents/[documentId]/process`**

Reprocess a document (re-chunk and re-embed).

**Authentication:** Required (must be owner)

**Success Response (200):**
```json
{
  "success": true,
  "status": "processing"
}
```

---

### Search Library

**`POST /api/v1/libraries/[libraryId]/search`**

Perform semantic search within a specific library.

**Authentication:** Required

**Request Body:**
```json
{
  "query": "How do I authenticate API requests?",
  "limit": 5,
  "threshold": 0.7
}
```

**Success Response (200):**
```json
{
  "results": [
    {
      "documentId": "doc_abc123",
      "documentTitle": "API Documentation",
      "content": "Authentication is handled via JWT tokens stored in httpOnly cookies...",
      "score": 0.92,
      "metadata": {
        "chunkIndex": 3
      }
    }
  ],
  "query": "How do I authenticate API requests?",
  "totalResults": 5
}
```

---

### Using Knowledge in Graphs

Knowledge Libraries integrate with the graph system through MCP tools. Add a tool step to your node configuration:

```json
{
  "steps": [
    {
      "id": "search-knowledge",
      "type": "tool",
      "config": {
        "toolName": "search_library",
        "parameters": {
          "libraryId": "lib_abc123",
          "query": "{{state.data.query.message}}",
          "userId": "{{state.data.options.userId}}"
        },
        "outputField": "data.knowledgeContext"
      }
    },
    {
      "id": "respond",
      "type": "neuron",
      "config": {
        "userPrompt": "Context:\n{{state.data.knowledgeContext}}\n\nQuestion: {{state.data.query.message}}"
      }
    }
  ]
}
```

**Available MCP Tools:**
- `list_libraries` - List user's accessible libraries
- `search_library` - Search a specific library
- `search_all_libraries` - Search across all user's libraries
- `get_library_info` - Get library metadata

---

## ÔøΩüë§ User Preferences

### Archive Management

Users can archive nodes and neurons to hide them from their default view without deleting them.

**`GET /api/v1/user/preferences/archive`**

Get user's archived nodes and neurons.

**Success Response (200):**
```json
{
  "archivedNodes": ["old-node-1", "old-node-2"],
  "archivedNeurons": ["old-neuron-1"]
}
```

**`POST /api/v1/user/preferences/archive`**

Archive a node or neuron.

**Request Body:**
```json
{
  "type": "node",
  "id": "node-to-archive"
}
```

**`DELETE /api/v1/user/preferences/archive`**

Unarchive a node or neuron.

**Request Body:**
```json
{
  "type": "node",
  "id": "node-to-unarchive"
}
```

---

## ü§ñ Models

### List Models

**`GET /api/v1/models`**

Get list of available AI models.

**Success Response (200):**
```json
{
  "object": "list",
  "data": [
    {
      "id": "Red",
      "object": "model",
      "created": 1698765432,
      "owned_by": "redbtn"
    }
  ]
}
```

---

## üßπ Cleanup

Admin endpoints for managing abandoned resources.

### Cleanup Abandoned Resources

**`POST /api/v1/cleanup/abandoned`**

Clean up abandoned nodes and neurons past their scheduled deletion date.

**Authentication:** Admin required (account level 1) or cron secret

**Query Parameters:**
- `dryRun` (boolean): If true, only reports what would be deleted
- `hardDelete` (boolean): If true, permanently removes. Otherwise marks as 'deleted'

**Success Response (200):**
```json
{
  "success": true,
  "dryRun": false,
  "result": {
    "nodesDeleted": 5,
    "neuronsDeleted": 2,
    "deletedNodeIds": ["old-node-1", "old-node-2"],
    "deletedNeuronIds": ["old-neuron-1"]
  }
}
```

**`GET /api/v1/cleanup/abandoned`**

Get statistics about abandoned resources pending cleanup.

**Success Response (200):**
```json
{
  "success": true,
  "statistics": {
    "readyForDeletion": { "nodes": 5, "neurons": 2 },
    "totalAbandoned": { "nodes": 15, "neurons": 8 },
    "pendingDeletion": {
      "nodes": [
        { "nodeId": "old-node", "abandonedAt": "2025-09-20", "scheduledDeletionAt": "2025-12-20" }
      ],
      "neurons": []
    }
  }
}
```

---

## üîê OAuth 2.0

redbtn supports OAuth 2.0 for third-party application authorization.

### Authorization Endpoint

**`GET /api/oauth/authorize`**

Initiate OAuth authorization flow. Displays consent screen.

**Query Parameters:**
- `client_id` (string, required): OAuth client ID
- `redirect_uri` (string, required): Callback URL
- `response_type` (string, required): Must be "code"
- `scope` (string): Space-separated scopes
- `state` (string): CSRF protection state

**`POST /api/oauth/authorize`**

Submit user consent decision.

---

### Token Endpoint

**`POST /api/oauth/token`**

Exchange authorization code for access token.

**Request Body (form-urlencoded):**
```
grant_type=authorization_code
code=AUTH_CODE
redirect_uri=https://app.example.com/callback
client_id=CLIENT_ID
client_secret=CLIENT_SECRET
```

**Success Response (200):**
```json
{
  "access_token": "eyJhbGc...",
  "token_type": "Bearer",
  "expires_in": 3600,
  "refresh_token": "dGhpcyBp...",
  "scope": "read write"
}
```

---

### Token Introspection

**`POST /api/oauth/introspect`**

Validate and get information about an access token.

---

### Token Revocation

**`POST /api/oauth/revoke`**

Revoke an access or refresh token.

---

### UserInfo Endpoint

**`GET /api/oauth/userinfo`**

Get user information using an access token.

**Headers:**
```
Authorization: Bearer ACCESS_TOKEN
```

**Success Response (200):**
```json
{
  "sub": "user_id",
  "email": "user@example.com",
  "name": "John Doe",
  "email_verified": true
}
```

---

### Client Management

**`GET /api/oauth/clients`**

List user's OAuth clients.

**`POST /api/oauth/clients`**

Register a new OAuth client.

**`GET /api/oauth/clients/[clientId]`**

Get OAuth client details.

**`DELETE /api/oauth/clients/[clientId]`**

Delete an OAuth client.

---

## üîç Logging & Monitoring

### Get Conversations with Logs

**`GET /api/v1/logs/conversations`**

Get list of conversations that have associated logs (for virtual terminal/debugging).

**Success Response (200):**
```json
{
  "success": true,
  "conversations": [
    {
      "conversationId": "conv_1234567890_abc123",
      "title": "AI Research",
      "logCount": 142,
      "lastLogAt": "2025-10-21T15:30:00.000Z",
      "generationCount": 5
    }
  ],
  "total": 1
}
```

---

### Get Logging Stats

**`GET /api/v1/logs/stats`**

Get logging system statistics.

**Query Parameters:**
- `conversationId` (string, optional): Get stats for specific conversation

**Success Response (200) - Without conversationId:**
```json
{
  "status": "operational",
  "message": "Logging system is running. Provide conversationId for detailed stats."
}
```

**Success Response (200) - With conversationId:**
```json
{
  "conversationId": "conv_1234567890_abc123",
  "totalLogs": 142,
  "generationCount": 5,
  "isGenerating": false,
  "byLevel": {
    "info": 100,
    "debug": 30,
    "warn": 10,
    "error": 2
  },
  "byCategory": {
    "llm": 45,
    "memory": 30,
    "router": 20,
    "tool": 25,
    "system": 22
  }
}
```

---

### Get Conversation Logs

**`GET /api/v1/conversations/[id]/logs`**

Get all logs for a specific conversation (for debugging/monitoring).

**Query Parameters:**
- `limit` (number, optional): Max logs to return, default 100
- `generationId` (string, optional): Filter by specific generation

**Success Response (200):**
```json
{
  "conversationId": "conv_1234567890_abc123",
  "logs": [
    {
      "timestamp": "2025-10-21T15:00:00.123Z",
      "level": "info",
      "category": "llm",
      "message": "Starting generation",
      "metadata": {
        "messageId": "msg_1234567890_xyz789",
        "model": "deepseek-chat"
      }
    },
    {
      "timestamp": "2025-10-21T15:00:01.456Z",
      "level": "debug",
      "category": "router",
      "message": "Route determined: CHAT",
      "metadata": {
        "intent": "chat",
        "confidence": 0.95
      }
    }
  ],
  "total": 2,
  "limit": 100
}
```

**Log Levels:**
- `debug` - Detailed debugging information
- `info` - General informational messages
- `warn` - Warning messages
- `error` - Error messages

**Log Categories:**
- `system` - System-level logs
- `llm` - Language model operations
- `memory` - Memory/database operations
- `router` - Routing decisions
- `tool` - Tool executions
- `stream` - Streaming operations

---

### Get Generation Info

**`GET /api/v1/generations/[generationId]`**

Get metadata about a specific generation.

**Success Response (200):**
```json
{
  "generationId": "gen_1234567890_abc123",
  "conversationId": "conv_1234567890_abc123",
  "messageId": "msg_1234567890_xyz789",
  "startTime": "2025-10-21T15:00:00.000Z",
  "endTime": "2025-10-21T15:00:05.000Z",
  "status": "completed",
  "tokenCount": 57,
  "model": "Red"
}
```

**Error Responses:**
- `400` - Missing generationId
- `404` - Generation not found
- `500` - Server error

---

### Get Generation Logs

**`GET /api/v1/generations/[generationId]/logs`**

Get all logs for a specific generation.

**Success Response (200):**
```json
{
  "generationId": "gen_1234567890_abc123",
  "logs": [
    {
      "timestamp": "2025-10-21T15:00:00.123Z",
      "level": "info",
      "category": "llm",
      "message": "Generation started"
    }
  ],
  "total": 1
}
```

---

## ‚ö° Rate Limiting

The API uses a token bucket algorithm for rate limiting with different tiers:

| Tier | Limit | Window | Applies To |
|------|-------|--------|------------|
| **AUTH** | 10 requests | 300s (5 min) | Authentication endpoints |
| **CHAT** | 30 requests | 60s (1 min) | Chat completions |
| **STANDARD** | 60 requests | 60s (1 min) | All other API endpoints |

**Rate Limit Headers:**

All responses include rate limit information:
```
X-RateLimit-Limit: 30
X-RateLimit-Remaining: 25
X-RateLimit-Reset: 1698765492
```

**Rate Limit Exceeded Response (429):**
```json
{
  "error": "Rate limit exceeded",
  "retryAfter": 15,
  "limit": 30,
  "window": 60
}
```

**Headers:**
```
Retry-After: 15
X-RateLimit-Limit: 30
X-RateLimit-Remaining: 0
X-RateLimit-Reset: 1698765492
```

---

## ‚ùå Error Handling

All error responses follow a consistent format:

**Error Response Structure:**
```json
{
  "error": "Error message",
  "message": "Detailed error description",
  "code": "ERROR_CODE"
}
```

**HTTP Status Codes:**

| Code | Meaning | Description |
|------|---------|-------------|
| `200` | OK | Request succeeded |
| `400` | Bad Request | Invalid request parameters |
| `401` | Unauthorized | Missing or invalid authentication |
| `404` | Not Found | Resource not found |
| `429` | Too Many Requests | Rate limit exceeded |
| `500` | Internal Server Error | Server-side error |

**Common Error Codes:**

- `invalid_request_error` - Malformed request
- `authentication_error` - Auth token invalid or missing
- `rate_limit_exceeded` - Too many requests
- `not_found` - Resource doesn't exist
- `internal_error` - Server-side failure

---

## üåä Streaming Protocol

The API uses Server-Sent Events (SSE) for streaming responses. This allows real-time updates and reconnection support.

### SSE Format

Each event is formatted as:
```
data: {JSON}\n\n
```

Multiple events are separated by blank lines.

### Event Types

**1. Metadata Events:**
- `init` - Stream initialization
- `complete` - Stream completion
- `error` - Error occurred

**2. Content Events:**
- `chunk` - Text content chunk
- `thinking` - AI reasoning/thinking content

**3. Status Events:**
- `status` - General status update
- `tool_status` - Tool execution status
- `tool_event` - Detailed tool events

### Stream Lifecycle

```
1. Client initiates request
   ‚Üì
2. Server sends "init" event
   ‚Üì
3. Server sends multiple "chunk" events
   ‚Üì
4. Server may send "thinking", "status", or "tool_event" events
   ‚Üì
5. Server sends "complete" event
   ‚Üì
6. Server sends "[DONE]" and closes stream
```

### Reconnection Flow

```
1. Client detects disconnect
   ‚Üì
2. Client calls /api/v1/messages/[messageId]/reconnect
   ‚Üì
3. Server sends "init" with existingContent
   ‚Üì
4. Server continues streaming new chunks
   ‚Üì
5. Stream completes normally
```

### Client Implementation Example

```typescript
const response = await fetch('/api/v1/chat/completions', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    model: 'Red',
    messages: [{ role: 'user', content: 'Hello!' }],
    stream: true
  })
});


  ## üß™ Local Testing & Debugging

  1. **Start the Next.js dev server** (from `webapp/`):
    ```bash
    npm run dev
    ```

  2. **Exercise a non-streaming completion**:
    ```bash
    curl -X POST http://localhost:3000/api/v1/chat/completions \
        -H "Content-Type: application/json" \
        -d '{
            "messages": [{"role":"user","content":"Hello"}],
            "stream": false
          }'
    ```

  3. **Test the streaming + reconnection path** by first POSTing to `/chat/completions` with `"stream": true`, then opening the returned `stream_url` in a second terminal with `curl -N http://localhost:3000{stream_url}`. Kill the curl process mid-way and re-open the same URL to confirm accumulated content is replayed.

  4. **Validate auth flow** with the magic-link endpoints:
    ```bash
    curl -X POST http://localhost:3000/api/auth/request-code \
        -H "Content-Type: application/json" \
        -d '{"email":"test@example.com","sessionId":"session_$(date +%s)_demo"}'
    ```

  5. **Inspect rate-limit headers**: every API response includes `X-RateLimit-*`. When hitting limits intentionally (e.g., `watch -n0.5 curl ...`), confirm `429` payloads match the docs above.

  These ad-hoc checks complement the built-in hook-based markdown cleanup and keep regressions obvious before pushing.

  ---
const reader = response.body?.getReader();
const decoder = new TextDecoder();

while (true) {
  const { done, value } = await reader.read();
  if (done) break;
  
  const chunk = decoder.decode(value);
  const lines = chunk.split('\n');
  
  for (const line of lines) {
    if (line.startsWith('data: ')) {
      const data = line.slice(6);
      if (data === '[DONE]') break;
      
      const event = JSON.parse(data);
      
      if (event.type === 'chunk') {
        process.stdout.write(event.content);
      } else if (event.type === 'complete') {
        console.log('\nTokens used:', event.metadata.tokens.total);
      }
    }
  }
}
```

---

## üìö Additional Resources

### Related Documentation

- **AI Package README**: `/ai/README.md` - Core AI library documentation
- **Deployment Guide**: `/ai/DEPLOYMENT.md` - Deployment strategies
- **API Server Guide**: `/ai/examples/SERVER.md` - Standalone server documentation
- **Rate Limiting Guide**: `/webapp/explanations/RATE-LIMITING.md` - Rate limiting details
- **Database Schema**: `/ai/DATABASE-MODULE.md` - Database structure

### Support

For questions, issues, or feature requests:
- Open an issue on GitHub
- Contact: support@redbtn.io

---

## üîÑ Changelog

### Version 2.0 (December 2025)
- **Nodes API** - Full CRUD, fork, abandon/restore lifecycle
- **Neurons API** - LLM configuration management with fork/abandon/restore
- **Graphs API** - Workflow management with fork capability
- **Archive System** - User-level hiding of nodes/neurons without deletion
- **Abandon System** - Soft-delete with 90-day retention and usage protection
- **Cleanup API** - Admin endpoints for managing abandoned resources
- **OAuth 2.0** - Full authorization server implementation
- **Node Preferences** - Save, favorite, recent tracking
- **Enhanced Node Listing** - Search, filtering, pagination, status tracking

### Version 1.0 (October 2025)
- Initial API release
- Chat completions with streaming
- Conversation management
- Authentication system
- Logging and monitoring
- Rate limiting
- Stream reconnection

---

**Built with üî¥ by redbtn**

Last Updated: December 20, 2025
